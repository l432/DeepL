\documentclass[11pt,a5paper,titlepage,twoside]{article} % Specifies the document class
%\usepackage[cp866nav]{inputenc}
\usepackage[cp1251]{inputenc}
\usepackage[intlimits,sumlimits]{amsmath}
\usepackage{enumerate,graphicx,dcolumn,amsthm}
\usepackage[english,russian,ukrainian]{babel}
\usepackage[footnotesize,bf]{caption2}
%\usepackage{amstext}
\usepackage{amssymb}
%\usepackage{cite}
%\usepackage {graphicx}

%\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{wrapfig}
%\usepackage{layout}


%\fontsize{14pt}
\renewcommand{\captionlabeldelim}{.}


\renewcommand{\vec}[1]{\mathbf{#1}}

\hoffset=-1in \voffset=-1in \topmargin=7mm \oddsidemargin=15mm
 \evensidemargin=20mm \textheight=165mm \textwidth 115mm


\theoremstyle{definition}
\newtheorem{Zavd}{Завдання}[part]


\title{Момот А. І., Оліх О. Я.\\\mbox{}\\МАТЕМАТИЧНЕ МОДЕЛЮВАННЯ\\\emph{Практичні заняття. \\ Частина 1.}}

%\author{Момот А. І., Оліх О. Я.}
\author{}
\date{}


\numberwithin{equation}{part}

%\ \leftmargini=0


\begin{document}           % End of preamble and beginning of text.
\maketitle
\newpage
%\layout
\renewcommand{\part}[1] {\refstepcounter{part}
{\bf Практичне заняття \thepart. #1 \par} \vspace{5mm plus 1mm minus
.5mm}}

\renewcommand{\theequation}{\thepart.\arabic{equation}}


\begin{abstract}
У методичній розробці наведено короткий огляд числових методів розв'язку алгебраїчних рівнянь та
систем лінійних алгебраїчних рівнянь; інтерполяції, апроксимації та інтегрування функцій однієї
змінної, а також алгоритми їх практичної реалізації. Викладений матеріал та завдання відповідають
робочій програмі дисципліни ``Математичне моделювання''.

Для студентів фізичного факультету Київського
національного університету імені Тараса Шевченка.
\end{abstract}

\setcounter{page}{3}
 \tableofcontents \clearpage


\part{Загальні властивості числових методів}
\addcontentsline{toc}{subsection}{\thepart. Загальні властивості числових методів}

Одним із найважливіших параметрів числового розв'язку задач, поряд із простотою обчислень та кількістю
математичних операцій, є величина похибки. Під час застосування числових методів похибки виникають
завжди. Використовуючи найбільш загальну класифікацію розрізняють усувні та неусувні похибки. У свою
чергу, усувні поділяють на похибки методу та похибки округлень, а неусувні
--- на похибки побудови математичної моделі та похибки, пов'язані з
наближеністю вхідних даних.

Розглянемо деякі особливості обчислювальної математики, які
безпосередньо пов'язані з величиною похибки кінцевого результату.
Серед них виділяють такі:

\newcounter{N}
\begin{list}{\arabic{N}.}{\usecounter{N} %
\setlength{\leftmargin}{0pt}%
\setlength{\topsep}{0.2cm}%
\setlength{\itemindent}{0.5cm}\setlength{\listparindent}{0.5cm}}

\item Обчислювальна математика оперує дискретними об'єктами: дійсне
число розглядається як число із плаваючою крапкою, відрізок --- як
система точок, неперервна функція
--- як таблична, тобто як набір значень аргументу та функції. Одним із
наслідків цього є поява похибки методу.

\item У комп'ютерному представленні числа мають обмежену кількість
знаків після коми і це є причиною того, що при обчисленнях з'являтиметься машинна похибка округлення. Розглянемо її появу на
прикладі. Припустимо, що необхідно розв'язати рівняння
\[
x^4-4x^3+8x^2-16x+15,99999999=0.
\]
Один зі шляхів розв'язку --- виділити четвертий степінь різниці:
\[
(x-2)^4-10^{-8}=0,
\]
\[
(x-2)^2=\pm10^{-4}.
\]
Таким чином, матимемо чотири розв'язки: $x_1=2,01$; $x_2=1,99$;
$x_3=2+0,01i$; $x_4=2-0,01i$. Водночас, якщо похибка
заокруглення $\delta_m>10^{-8}$, то число $15,99999999$ буде замінене
на 16 і отримається рівняння
\[
(x-2)^4=0.
\]
Його чотири розв'язки є однаковими \mbox{$x_1=x_2=x_3=x_4=2$} і відрізняються від точних розв'язків.

Для характеристики цього явища вводять поняття машинного епсілон: це
таке число $\varepsilon_m$, для якого при комп'ютерних розрахунках
\[ 1+\varepsilon_m=1. \]
$\varepsilon_m$ описує відносну похибку машинного заокруглення (або
відносну відстань між машинними числами); його значення залежить від
того, який обсяг пам'яті виділяється для збереження одного числа.

\item Існує поняття зумовленості розв'язку, тобто
чутливості розв'язку до малих змін вхідних даних. Наприклад, система
рівнянь
\[
\left\{
  \begin{array}{rcl}
  x+10y&=&11;\\
  100x+1001y&=&1101\\
  \end{array}
\right.
\]
має розв'язок  $x=1$, $y=1$. Якщо додати до правої частини першого
рівняння всього одну соту (змінити її на 0,01), то матимемо систему
\[
\left\{
  \begin{array}{rcl}
  x+10y&=&11,01;\\
  100x+1001y&=&1101\\
  \end{array}
\right.
\]
із розв'язком $x=11,01$, $y=0,00$. Тобто, вихідна система
погано зумовлена: відносно невелика зміна вихідних даних призвела до
значних змін розв'язку.

До речі, у прикладі з попереднього пункту також погана зумовленість:
абсолютна похибка у вільному члені порядку $10^{-8}$ призвела до
похибок розв'язку близько $10^{-2}$.

\item Вибір алгоритму обчислень може впливати на їх результат.
Наприклад, якщо обчислювати значення функції $\exp(x)$ за допомогою
її розвинення в ряд
\[
\exp(x)=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\ldots,
\]
то виявляється, що для додатних значень аргументу обчислення
функ\-ції у такий спосіб дає цілком прийнятні значення. Водночас,
для отримання правильного результату при $x<0$ необхідно скористатися
тим, що $\exp(-x)=[\exp(x)]^{-1}$, тобто спочатку за допомогою ряду
обчислити значення функції для модуля аргументу, а вже потім
порахувати величину, обернену до отриманої в результаті обчислення
суми.

\item Алгоритм обчислень має бути економічним, тобто з мінімізованою
кількістю елементарних операцій. Для ілюстрації знайдемо суму
\[  S=1+x+x^2+x^3+\ldots+x^{1023} \quad \mbox{ } \; (0<x<1).\]
Якщо обчислювати кожен із доданків як
\[x,\;x^2=x\cdot x,\;x^3=x^2\cdot x,\;\dots,\; x^{1023}=x^{1022} \cdot x\]
то потрібно буде виконати 1022 операції множення і 1023 операції додавання,
причому кожна з них буде характеризуватися похибками, пов'язаними з
машинним округленням результату. З іншого боку, якщо скористатись
виразом, який описує суму прогресії
\[ S=\frac{1-x^{1024}}{1-x}, \]
та врахувати, що $x^2=x\cdot x$, $x^4=x^2\cdot x^2$, \dots, $x^{1024}=x^{512}\cdot x^{512}$, то
необхідно буде виконати всього 10 операцій множення, одну ділення та дві віднімання.

\end{list}



\vspace{.3cm}
\begin{Zavd}\label{Z11}
Написати програму пошуку машинного епсілон для чисел типу float та
double.
\end{Zavd}

\begin{Zavd}\label{Z12}
Написати програму обчислення функції за допомогою її розвинення у
степеневий ряд
\[
f(x)=\sum_{k=0}^{\infty}a_kx^k \; \Rightarrow \;
f(x)\approx\sum_{k=0}^{N-1}a_kx^k, \quad |\,a_Nx^N|<\varepsilon,
\]
із точністю $\varepsilon=10^{-8}$ на прикладі $f(x)=\sin(x)$, $f(x)=\cos(x)$,
\linebreak[4]\mbox{$f(x)=\exp(x)$}.

\vspace{.5cm}
\noindent \emph{Примітка:}
\begin{equation*}
\begin{split}
&\exp(x)=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\ldots\\
&\sin(x)=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+\ldots\\
&\cos(x)=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+\ldots
\end{split}
\end{equation*}
\end{Zavd}

\begin{Zavd}\label{Z13}
Написати функцію, яка читає дані з файла, що складається зі
стовців чисел, і заповнює ними задані масиви (масив).
\end{Zavd}



\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

Запропоновані в цьому та наступному розділах алгоритми носять назву
``орієнтовні'' через те, що вони висвітлюють особливості реалізації
саме числових методів і не завжди відображають усі деталі, які
потрібно врахувати для того, щоб програма працювала стабільно.
Наприклад, перед відкриттям файла бажано перевірити чи він
взагалі існує на диску; під час зчитування числових даних варто
переконатися чи дійсно цифри внесено у файл (набрано користувачем на
клавіатурі); якщо очікується, що дані у файлі розташовано у декілька
стовпців, то слід перевірити, чи кожен рядок містить однакову
кількість чисел тощо. Але всі ці моменти більше стосуються якості та
рівня програмування і в наведених алгоритмах не будуть відображатися.

\vspace{.5cm} \emph{Завдання \ref{Z12}}

 Розглянемо розв'язок завдання на прикладі функції $\sin(x)$. Як відомо з курсу
 математичного аналізу, її розвинення у ряд
 можна записати у вигляді  $$\sin(x)=\sum_{k=0}^\infty
q_k,\quad \text{ де } q_k=(-1)^k\frac{x^{2k+1}}{(2k+1)!}\,.$$ Легко
побачити, що, зокрема,
$$q_2=\frac{x^5}{5!}=\frac{x^3\cdot x^2}{3!\cdot4\cdot5}=-q_1\frac{x^2}{4\cdot5}\,,$$
і, загалом, два послідовні доданки пов'язані між собою
співвідношенням
$$q_{k+1}=-\frac{x^2}{(2k+2)(2k+3)}\cdot{q_k}, \quad q_0=x.$$ Тобто,
для обчислення $k$-го доданка не потрібно  безпосередньо шукати
значення виразів $x^{2k+1}$ і $(2k+1)!$, а можна скористатись
отриманим вище співвідношенням, що суттєво зменшить кількість
операцій.

Таким чином, сам алгоритм можна записати у вигляді послідовності
операцій, приведених нижче.

\begin {enumerate} [i.]

%\begin{list}{\roman{N})}{\usecounter{N} %
%\setlength{\leftmargin}{0pt}%
%\setlength{\topsep}{0.0cm}%
%\setlength{\itemindent}{0.5cm} \setlength{\listparindent}{0.5cm}}
%\setlength{\itemsep}{0.0cm}

\item У діалоговому режимі зчитати із клавіатури значення аргументу,
для якого необхідно розрахувати значення функції.

\item Обчислити перший доданок $q_0$ і присвоїти його значення результату.

\item Спираючись на значення попереднього доданка, обчислити наступний. {\label{1.2.2}}

\item Порівняти \emph{модуль} отриманого доданка з $\varepsilon$. Якщо
значення $\varepsilon$ більше, то перейти до п.\ref{1.2.1}.

\item Додати отриманий доданок до результату. Перейти до п.\ref{1.2.2}.


\item Вивести на екран результат.{\label{1.2.1}}

\item Для порівняння вивести на екран значення функції для цього ж аргументу,
обчислене за допомогою вбудованих функцій.
%\end{list}
\end{enumerate}


\vspace{.1cm} \emph{Завдання \ref{Z13}}
\begin {enumerate} [i.]
%\setlength{\topsep}{0.0cm}
%\setlength{\itemsep}{0.0cm}
%\setlength{\partopsep}{0.0cm}
\item У діалоговому режимі отримати з клавіатури назву файлу та кількість стовпців.

\item Відкрити файл для читання.

\item Визначити кількість рядків (наприклад, читаючи дані з файла
аж до його закінчення;
після досягнення кінця файла повернути вказівник на початок).

\item Створити масив необхідного розміру.

\item Зчитати дані з файла в масив.
\item Закрити файл.
\item Вивести дані з масиву на екран.

\end{enumerate}
 \clearpage

\part{Алгебраїчні рівняння}
\addcontentsline{toc}{subsection}{\thepart. Алгебраїчні рівняння}

Задачу розв'язку алгебраїчного рівняння можна звести до пошуку таких
значень аргументу функції $f(x)$, при яких значення самої функції
дорівнює нулеві,
\[
f(x)=0, \quad x - ?\,;
\]
тобто знайти точки перетину графіка функції $f(x)$ із віссю $x$. При
розв'язанні цієї задачі, насамперед,
постає завдання знайти діапазон значень аргументу, де може бути розташований розв'язок. Розглянемо
приклад, наведений на рис.~\ref{pic1}. Значення функції у точці $x_1$ є додатним, а у точці $x_2$ ---
від'ємним, тому, очевидно, між цими точками знаходиться значення $x$ таке, що $f(x)=0$. Отже,
відрізок $[\,a,b\,]$, на якому шукається розв'язок, слід вибирати з умови

\begin{equation}
\label{fafb}
 f(a)\cdot f(b)<0.
\end{equation}

Умова (\ref{fafb}) не гарантує, що на відрізку є лише один корінь,
наприклад $f(x_1)\cdot f(x_4)<0$, а коренів між цими точками три. І
навпаки,  якщо умова (\ref{fafb}) не виконується, то це може
означати, що на вибраному проміжку коренів немає, як, наприклад на
відрізку $[x_4,x_5]$, або їх є декілька --- відрізок $[x_1,x_3]$.
Окремим є випадок $ f(a)\cdot f(b)=0$, коли кінець відрізка
збігається із коренем рівняння.

\begin{figure}[htb]
 \centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (18.06,57.94) rectangle +(115.11,46.64);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (20.06,69.87) -- (130.07,70.19);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (130.07,70.19) -- (127.27,70.88) -- (130.07,70.19) --
(127.28,69.48) -- (130.07,70.19) -- cycle; \path[line width=0.30mm, draw=L] (129.18,60.93) .. controls
(125.30,61.20) and (121.41,61.41) .. (117.53,61.55) .. controls (110.49,61.81) and (103.15,61.98) ..
(97.32,65.95) .. controls (91.74,69.74) and (88.10,76.72) .. (81.27,77.52) .. controls (70.61,78.77)
and (65.27,65.07) .. (55.15,63.71) .. controls (45.39,62.40) and (38.65,71.67) .. (33.89,80.87) ..
controls (30.56,87.30) and (27.33,93.77) .. (24.18,100.28); \draw(29.52,92.41) node[anchor=base west]{
\small $f(x)$}; \path[line width=0.30mm, draw=L] (22.70,59.94) -- (22.70,102.58); \path[line
width=0.30mm, draw=L, fill=F] (22.70,102.58) -- (22.00,99.78) -- (22.70,102.58) -- (23.40,99.78) --
(22.70,102.58) -- cycle; \draw(127.42,73.23) node[anchor=base]{ \small $x$}; \draw(30.10,64.52)
node[anchor=base]{ \small $x_1$}; \path[line width=0.30mm, draw=L, fill=F] (30.14,69.98) circle
(0.53mm); \draw(50.20,72.58) node[anchor=base]{ \small $x_2$}; \path[line width=0.30mm, draw=L,
fill=F] (49.97,69.98) circle (0.53mm); \draw(82.45,64.52) node[anchor=base]{ \small $x_3$}; \path[line
width=0.30mm, draw=L, fill=F] (82.20,69.98) circle (0.53mm); \draw(99.78,72.58) node[anchor=base]{
\small $x_4$}; \path[line width=0.30mm, draw=L, fill=F] (99.55,69.98) circle (0.53mm);
\draw(114.09,72.58) node[anchor=base]{ \small $x_5$}; \path[line width=0.30mm, draw=L, fill=F]
(114.43,69.98) circle (0.53mm); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm]
(30.21,70.09) -- (30.21,88.39); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm]
(49.92,69.89) -- (49.91,64.09); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm]
(82.16,70.40) -- (82.16,77.37); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm]
(99.55,70.19) -- (99.49,64.71); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm]
(114.41,69.49) -- (114.41,61.70);
\end{tikzpicture}
\caption{ \bf Можливе взаємне розташування коренів рівняння та
границь відрізку, де шукається розв'язок} \label{pic1}
\end{figure}

 Питання щодо локалізації кореня (тобто про визначення границь відрізка),
як правило, алгоритмічно не розв'язується; це, швидше, питання
майстерності того, хто проводить обчислення. Проте в багатьох
випадках локалізувати корінь досить просто. Один із найпростіших
підходів
--- вибрати початковий відрізок довільної ширини $d$ таким чином,
щоб одна з його границь збігалася з
точкою $x=0$, а потім зміщувати його на всю ширину до праворуч або ліворуч доти,
 поки добуток значень
функції у його крайніх точках не буде від'ємним або нульовим.

Розглянемо основні методи числового розв'язку алгебраїчних рівнянь.


\begin{list}{\arabic{N}.}{\usecounter{N} %
\setlength{\leftmargin}{0pt}%
\setlength{\topsep}{0.2cm}%
\setlength{\itemindent}{0.5cm}\setlength{\listparindent}{0.5cm}}

\item
\textbf{\emph{Метод ділення навпіл (або дихотомія чи бісекція)}}


Цей метод полягає у тому, що вихідний відрізок ділиться навпіл
точкою (рис.~\ref{1/2}):
\begin{equation}
c=\frac{a+b}{2}\;. \label{b0}
\end {equation}
Якщо $f(a)\cdot f(c) \leqslant 0$, тоді точка $c$ стає правим
кінцем нового відрізка ($b\to c$, відрізок $[\,a,b\,]$ замінюється
на $[\,a,c\,]$, рис.~\ref{1/2},б); якщо $f(a)\cdot
f(c) > 0$, то точка $c$ стає лівим кінцем відрізка ($a\to c$, цей
 випадок зображено на рис.~\ref{1/2},а).


\begin{figure}[htb]
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt,scale=0.97]
\path[line width=0mm] (15.20,61.32) rectangle +(117.21,36.21);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (23.99,73.58) -- (75.04,73.69);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (75.04,73.69) -- (72.24,74.39) -- (75.04,73.69) --
(72.24,72.99) -- (75.04,73.69) -- cycle; \path[line width=0.30mm, draw=L] (71.52,95.53) .. controls
(69.33,93.94) and (67.36,92.07) .. (65.65,89.97) .. controls (60.35,83.43) and (57.21,74.47) ..
(49.14,71.71) .. controls (46.82,70.91) and (44.34,70.80) .. (41.89,70.62) .. controls (38.98,70.41)
and (36.05,70.09) .. (33.35,68.97) .. controls (30.61,67.82) and (28.26,65.88) .. (26.60,63.41);
\draw(61,92.99) node[anchor=base west]{ \small $f(x)$}; \path[line width=0.30mm, draw=L] (23.95,63.32)
-- (24.09,93.80); \path[line width=0.30mm, draw=L, fill=F] (24.09,93.80) -- (23.38,91.01) --
(24.09,93.80) -- (24.78,91.00) -- (24.09,93.80) -- cycle; \draw(70.98,75.58) node[anchor=base]{ \small
$x$}; \path[line width=0.30mm, draw=L, fill=F] (29.03,73.56) circle (0.33mm); \path[line width=0.30mm,
draw=L, fill=F] (46.27,73.56) circle (0.33mm); \path[line width=0.30mm, draw=L, fill=F] (62.60,73.62)
circle (0.33mm); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm] (28.97,66.30) --
(29.01,73.55); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm] (46.33,73.39) --
(46.37,71.12); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm] (62.51,85.74) --
(62.65,73.80); \draw(29.05,74.97) node[anchor=base]{ \small $a$}; \path[line width=0.30mm, draw=L,
dash pattern=on 0.30mm off 0.50mm] (28.95,66.22) -- (23.91,66.24); \draw(17,65.73) node[anchor=base
west]{\small $f(a)$}; \draw(61.92,70.32) node[anchor=base west]{\small $b$}; \draw(45.73,74.97)
node[anchor=base west]{ \small $c$}; \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off
0.50mm] (62.45,85.75) -- (23.97,85.75); \draw(17,85.00) node[anchor=base west]{ \small $f(b)$};
\path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm] (46.37,71.12) -- (23.97,71.18);
\draw(17,70.55) node[anchor=base west]{ \small $f(c)$}; \path[line width=0.30mm, draw=L] (79.35,73.58)
-- (130.41,73.69); \path[line width=0.30mm, draw=L, fill=F] (130.41,73.69) -- (127.61,74.39) --
(130.41,73.69) -- (127.61,72.99) -- (130.41,73.69) -- cycle; \path[line width=0.30mm, draw=L]
(126.89,95.53) .. controls (124.70,93.94) and (122.72,92.07) .. (121.02,89.97) .. controls
(115.72,83.43) and (112.58,74.47) .. (104.51,71.71) .. controls (102.18,70.91) and (99.70,70.80) ..
(97.25,70.62) .. controls (94.35,70.41) and (91.41,70.09) .. (88.72,68.97) .. controls (85.97,67.82)
and (83.62,65.88) .. (81.97,63.41); \draw(116,92.99) node[anchor=base west]{ \small $f(x)$};
\path[line width=0.30mm, draw=L] (79.31,63.32) -- (79.46,93.80); \path[line width=0.30mm, draw=L,
fill=F] (79.46,93.80) -- (78.75,91.01) -- (79.46,93.80) -- (80.15,91.00) -- (79.46,93.80) -- cycle;
\draw(126.35,75.58) node[anchor=base]{\small $x$}; \path[line width=0.30mm, draw=L, fill=F]
(110.19,73.56) circle (0.33mm); \path[line width=0.30mm, draw=L, fill=F] (101.64,73.56) circle
(0.33mm); \path[line width=0.30mm, draw=L, fill=F] (117.97,73.62) circle (0.33mm); \draw(101.48,74.97)
node[anchor=base]{ \small $a$}; \draw(117.29,70.32) node[anchor=base west]{\small $b$};
\draw(109.44,70.12) node[anchor=base west]{\small $c$};
\end{tikzpicture}%
\caption{ \bf Ілюстрація до методу ділення навпіл, а --- перший крок, б --- другий} \label{1/2}
\end{figure}

Операція поділу повторюється, поки не починає виконуватись одна
з таких умов:
\begin{eqnarray}
|\,f(c)|&<&\delta\;; \label{b1}\\
|\,b-a|&<&\delta_x\;;  \label{b2}\\
|\,b-a|&<&\varepsilon_x\cdot b\;, \label{b3}
\end{eqnarray}
де $\delta$ --- абсолютна точність визначення функції, а умови
\eqref{b2} та \eqref{b3} описують порівняння відрізка з абсолютною та
відносною точністю знаходження кореня відповідно. Розв'язком
вважається координата однієї із границь кінцевого відрізка. Часто
достатньо відслідковувати лише виконання умови \eqref{b2}.

За вдалого вибору початкових значень $a$ та $b$ метод
збігається завжди. Якщо ж функція має вигляд, подібний до зображеного
на рис.~\ref{pic3}, то, не зважаючи на те, що на відрізку $[\,a,b\,]$
умова \eqref{fafb} задовольняється,  кореня там немає і метод ділення
навпіл може дати хибний розв'язок. Аби уникнути подібної ситуації,
необхідно контролювати зростання значення функції у точці $c$,
порівняно з $f(a)$ і $f(b)$.

\begin{figure}
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (38.00,53.16) rectangle +(114.48,43.76);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (40.00,73.58) -- (92.37,73.77);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (92.37,73.77) -- (89.56,74.46) -- (92.37,73.77) --
(89.57,73.06) -- (92.37,73.77) -- cycle; \path[line width=0.30mm, draw=L] (91.78,75.42) .. controls
(89.46,75.60) and (87.13,75.76) .. (84.80,75.91) .. controls (81.01,76.14) and (77.08,76.38) ..
(73.94,78.52) .. controls (71.58,80.14) and (70.01,82.62) .. (68.80,85.21) .. controls (67.37,88.29)
and (66.39,91.56) .. (65.89,94.91); \draw(69.94,86.59) node[anchor=base west]{\small  $f(x)$};
\path[line width=0.30mm, draw=L] (63.76,55.16) -- (63.95,93.80); \path[line width=0.30mm, draw=L,
fill=F] (63.95,93.80) -- (63.23,91.01) -- (63.95,93.80) -- (64.63,91.00) -- (63.95,93.80) -- cycle;
\draw(88.34,70.44) node[anchor=base]{\small  $x$}; \path[line width=0.30mm, draw=L, fill=F]
(68.59,73.66) circle (0.33mm); \path[line width=0.30mm, draw=L, fill=F] (56.55,73.66) circle (0.33mm);
\path[line width=0.30mm, draw=L, fill=F] (79.96,73.62) circle (0.33mm); \draw(56.58,74.97)
node[anchor=base]{\small  $a$}; \draw(79.18,70.32) node[anchor=base west]{\small  $b$};
\draw(67.94,70.41) node[anchor=base west]{\small  $c$}; \path[line width=0.30mm, draw=L] (40.10,72.22)
.. controls (42.77,72.05) and (45.43,71.69) .. (48.05,71.15) .. controls (52.02,70.34) and
(56.00,69.03) .. (58.66,65.98) .. controls (60.54,63.82) and (61.49,61.06) .. (62.05,58.25) ..
controls (62.24,57.29) and (62.39,56.32) .. (62.50,55.35); \path[line width=0.30mm, draw=L]
(98.12,73.58) -- (150.48,73.77); \path[line width=0.30mm, draw=L, fill=F] (150.48,73.77) --
(147.68,74.46) -- (150.48,73.77) -- (147.69,73.06) -- (150.48,73.77) -- cycle; \path[line
width=0.30mm, draw=L] (112.21,90.97) .. controls (116.04,88.17) and (119.33,84.71) .. (121.93,80.75)
.. controls (123.76,77.95) and (125.50,74.77) .. (128.74,73.93) .. controls (133.35,72.74) and
(137.36,76.61) .. (139.46,81.25) .. controls (141.00,84.65) and (141.82,88.33) .. (141.87,92.07);
\draw(134.07,86.59) node[anchor=base west]{\small  $f(x)$}; \path[line width=0.30mm, draw=L]
(121.88,55.16) -- (122.06,93.80); \path[line width=0.30mm, draw=L, fill=F] (122.06,93.80) --
(121.35,91.01) -- (122.06,93.80) -- (122.75,91.00) -- (122.06,93.80) -- cycle; \draw(146.45,70.44)
node[anchor=base]{\small  $x$}; \path[line width=0.30mm, draw=L, fill=F] (114.67,73.66) circle
(0.33mm); \path[line width=0.30mm, draw=L, fill=F] (138.08,73.62) circle (0.33mm); \draw(114.70,74.97)
node[anchor=base]{\small  $a$}; \draw(137.30,70.32) node[anchor=base west]{\small  $b$};
\end{tikzpicture}\\
\parbox[t]{0.47\textwidth}{\caption{ \bf Хибний розв'язок} \label{pic3}} \hfill
\parbox[t]{0.47\textwidth}{\caption{ \bf Корінь, який не можна знайти методом ділення навпіл}\label{pic4}}
\end{figure}

Також методом ділення навпіл неможливо знайти корінь подібний до
зображеного на рис.~\ref{pic4}, адже не можна вибрати відрізок
$[\,a,b\,]$, який містить корінь і при цьому функція має різні знаки
на його границях.

\item
\textbf{\emph{Метод хорд}}

Цей метод відрізняється від методу дихотомії  способом пошуку нової
границі відрізка --- точки $c$. Положення $c$ визначається з
умови
\begin{equation}
c=a-f(a)\cdot\frac{b-a}{f(b)-f(a)}\;. \label{b41}
\end{equation}
Як видно з рис.~\ref{pic5}, точка $c$ є перетином хорди $AB$ з віссю $x$ і у цьому
випадку вона знаходиться ближче до кореня, ніж середина відрізка
$[\,a,b\,]$. Для подібних трикутників $Aac$ і $Bbc$ можна записати
відношення $-f(a)/(c-a)=f(b)/(b-c)$, звідки
\begin{equation*}
c=\frac{af(b)-bf(a)}{f(b)-f(a)}\;,
\end{equation*}
що дозволяє легко отримати вираз \eqref{b41}. Тобто, у цьому методі
при визначенні положення нової границі, окрім знака функції на кінцях
відрізка, враховується і її значення.

Після визначення $c$ зміна границі відрізка відбувається  так само,
як у методі ділення навпіл.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (-2.82,-2.82) rectangle +(95.56,55.58);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L] (10.53,15.93) -- (89.78,16.10);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L, fill=F] (89.78,16.10) -- (86.98,16.79) -- (89.78,16.10) --
(86.98,15.39) -- (89.78,16.10) -- cycle; \path[line width=0.3mm, draw=L] (89.91,46.41) .. controls
(84.28,46.17) and (78.66,45.55) .. (73.10,44.57) .. controls (66.13,43.34) and (59.26,41.54) ..
(52.74,38.79) .. controls (43.62,34.95) and (35.35,29.34) .. (28.31,22.37) .. controls (24.95,19.05)
and (21.90,15.44) .. (18.98,11.73) .. controls (16.33,8.36) and (13.79,4.90) .. (11.37,1.36);
\draw(75.41,40.54) node[anchor=base west]{\small  $f(x)$}; \path[line width=0.3mm, draw=L]
(10.47,0.00) -- (10.32,48.77); \path[line width=0.3mm, draw=L, fill=F] (10.32,48.77) -- (9.62,45.97)
-- (10.32,48.77) -- (11.02,45.98) -- (10.32,48.77) -- cycle; \draw(83.48,19.03)
node[anchor=base]{\small  $x$}; \path[line width=0.3mm, draw=L, fill=F] (18.36,15.89) circle (0.4mm);
\path[line width=0.3mm, draw=L, fill=F] (44.34,15.89) circle (0.4mm); \path[line width=0.3mm, draw=L,
fill=F] (69.95,15.99) circle (0.4mm); \path[line width=0.3mm, draw=L, dash pattern=on 0.42mm off
0.71mm] (18.46,11.21) -- (18.46,15.49); \path[line width=0.3mm, draw=L, dash pattern=on 0.42mm off
0.71mm] (70.08,43.65) -- (70.08,16.20); \draw(18.39,18.09) node[anchor=base]{\small  $a$}; \path[line
width=0.3mm, draw=L, dash pattern=on 0.42mm off 0.71mm] (18.24,11.06) -- (10.42,11.10);
\draw(3.00,9.00) node[anchor=base west]{\small  $f(a)$}; \draw(69.42,10.86) node[anchor=base
west]{\small  $b$}; \draw(24.85,11.12) node[anchor=base west]{\small  $c$}; \path[line width=0.3mm,
draw=L, dash pattern=on 0.42mm off 0.71mm] (70.23,43.74) -- (10.51,43.74); \draw(3.00,42.19)
node[anchor=base west]{\small  $f(b)$}; \path[line width=0.21mm, draw=L] (69.95,43.91) --
(18.46,10.95); \path[line width=0.3mm, draw=L, fill=F] (26.21,15.89) circle (0.4mm);
\draw(40.53,19.35) node[anchor=base west]{\small $\frac{a+b}{2}$}; \draw(17.67,5.69) node[anchor=base
west]{\small  $A$}; \draw(68.77,46.02) node[anchor=base west]{\small  $B$};
\end{tikzpicture}%
\caption{ \bf Ілюстрація до пошуку наступного наближення до розв'язку у методі хорд} \label{pic5}
\end{figure}

У цьому випадку критерій \eqref{b2} незастосовний. Наприклад, у
випадку, зображеному на рис.~\ref{pic6}, положення точки $b$ не змінюється,
точка $c$ із кожним кроком наближається до кореня, але відрізок
$[\,c_k,b\,]$ не стає малим ($c_k$ --- нова границя відрізку, отримана
під час $k$-го кроку). В цьому випадку
можна порівнювати взаємне розташування точок, отриманих
під час послідовних наближень, тобто використовувати умову
\begin{equation}
|\,c_k-c_{k-1}|<\delta_x\;, \label{b4}
\end {equation}
або можна застосовувати умову \eqref{b1}.

\begin{figure}[htb]
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (16.75,57.94) rectangle +(66.36,42.98);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (19.34,72.35) -- (81.11,72.49);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (81.11,72.49) -- (78.31,73.18) -- (81.11,72.49) --
(78.31,71.78) -- (81.11,72.49) -- cycle; \path[line width=0.30mm, draw=L] (76.85,98.92) .. controls
(74.02,97.22) and (71.60,94.92) .. (69.75,92.18) .. controls (65.80,86.33) and (64.68,78.77) ..
(59.62,73.78) .. controls (54.77,69.01) and (47.74,67.82) .. (40.96,67.24) .. controls (37.24,66.91)
and (33.48,66.72) .. (29.85,65.85) .. controls (26.80,65.11) and (23.89,63.91) .. (21.22,62.27);
\draw(64.88,95.84) node[anchor=base west]{\small  $f(x)$}; \path[line width=0.30mm, draw=L]
(19.29,59.94) -- (19.47,96.82); \path[line width=0.30mm, draw=L, fill=F] (19.47,96.82) --
(18.75,94.02) -- (19.47,96.82) -- (20.15,94.02) -- (19.47,96.82) -- cycle; \draw(76.20,74.77)
node[anchor=base]{\small  $x$}; \path[line width=0.30mm, draw=L, fill=F] (25.54,72.33) circle
(0.40mm); \path[line width=0.30mm, draw=L, fill=F] (37.87,72.33) circle (0.40mm); \path[line
width=0.30mm, draw=L, fill=F] (70.03,72.40) circle (0.40mm); \path[line width=0.30mm, draw=L, dash
pattern=on 0.30mm off 0.50mm] (25.48,64.30) -- (25.61,72.46); \path[line width=0.30mm, draw=L, dash
pattern=on 0.30mm off 0.50mm] (69.93,92.54) -- (70.09,72.62); \draw(25.46,74.04)
node[anchor=base]{\small  $a$}; \draw(69.11,68.40) node[anchor=base west]{\small  $b$};
\draw(35.97,73.76) node[anchor=base west]{\small  $c_1$}; \path[line width=0.30mm, draw=L, dash
pattern=on 0.30mm off 0.50mm] (69.93,92.34) -- (19.32,92.24); \path[line width=0.15mm, draw=L]
(25.18,64.36) -- (69.74,92.34); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm]
(37.81,67.12) -- (37.89,72.32); \path[line width=0.15mm, draw=L] (37.81,67.26) -- (69.88,92.38);
\path[line width=0.30mm, draw=L, fill=F] (44.33,72.33) circle (0.40mm); \draw(42.35,73.69)
node[anchor=base west]{\small  $c_2$}; \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm off
0.50mm] (44.27,67.61) -- (44.34,72.25); \path[line width=0.15mm, draw=L] (44.27,67.75) --
(69.88,92.38); \draw(47.90,69.83) node[anchor=base west]{\small  $c_3$}; \path[line width=0.30mm,
draw=L, fill=F] (48.99,72.40) circle (0.40mm);
\end{tikzpicture}
\caption{ \bf Ілюстрація до вибору критерію припинення процесу в методі хорд}\label{pic6}
\end{figure}

У випадках, проілюстрованих рисунками ~\ref{pic3} та ~\ref{pic4}, при використанні
методу хорд виникають ті самі труднощі із пошуком кореня, що і
при застосуванні методі бісекції.


\item
\textbf{\emph{Метод Ньютона (або дотичних чи лінеаризації)}}

У цьому випадку розташування точки, більш наближеної до шуканого
розв'язку, вибирається в місці перетину дотичної до графіка функції
$f(x)$ при $x=b$ та осі абсцис (рис.~\ref{pic7}).
Урахувавши, що, з одного боку, $\mathrm{tg}\,\alpha=f'(b)$, а з
іншого, $\mathrm{tg}\,\alpha=f(b)/(b-c)$, отримуємо умову для
визначення положення нової границі відрізка:
\begin{equation}
c=b-\frac{f(b)}{f'(b)}\;.\label{b31}
\end {equation}

Очевидно, функція повинна бути такою, щоб від неї можна було
аналітично знайти похідну. Подальше звуження відрізка відбувається
так само, як і у попередніх випадках. При цьому мають виконуватись
умови
\begin{equation}\label{umova}
\left\{
  \begin{array}{rcl}
  f(b)\cdot f'(b)&>&0\;;\\
  b-f(b)/f'(b)&>&a.\\
  \end{array}
\right.
\end{equation}

\begin{figure}[bt]
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (3.21,7.82) rectangle +(83.53,42.96);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (15.87,15.97) -- (84.73,16.06);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (84.73,16.06) -- (81.93,16.76) -- (84.73,16.06) --
(81.93,15.36) -- (84.73,16.06) -- cycle; \path[line width=0.30mm, draw=L] (71.65,45.01) .. controls
(71.07,40.54) and (69.23,36.33) .. (66.36,32.86) .. controls (63.84,29.82) and (60.63,27.47) ..
(57.26,25.43) .. controls (50.80,21.52) and (43.76,18.70) .. (36.48,16.71) .. controls (30.51,15.08)
and (24.42,14.00) .. (18.33,12.94) .. controls (17.73,12.84) and (17.13,12.73) .. (16.52,12.63);
\draw(43.93,24.53) node[anchor=base west]{\small  $f(x)$}; \path[line width=0.30mm, draw=L]
(15.83,10.09) -- (15.88,48.77); \path[line width=0.30mm, draw=L, fill=F] (15.88,48.77) --
(15.18,45.98) -- (15.88,48.77) -- (16.58,45.97) -- (15.88,48.77) -- cycle; \draw(79.77,19.03)
node[anchor=base]{\small  $x$}; \path[line width=0.30mm, draw=L, fill=F] (23.93,15.89) circle (0.4mm);
\path[line width=0.30mm, draw=L, fill=F] (60.39,15.99) circle (0.4mm); \path[line width=0.30mm,
draw=L, fill=F] (70.04,15.99) circle (0.4mm); \path[line width=0.30mm, draw=L, dash pattern=on 0.30mm
off 0.50mm] (70.03,38.69) -- (70.08,16.01); \draw(23.96,18.09) node[anchor=base]{\small  $a$};
\draw(69.42,10.86) node[anchor=base west]{\small  $b$}; \draw(59.00,11.31) node[anchor=base
west]{\small  $c_1$}; \path[line width=0.30mm, draw=L, fill=F] (44.59,15.89) circle (0.4mm);
\path[line width=0.15mm, draw=L] (73.13,45.57) -- (58.47,11.70); \path[line width=0.30mm, draw=L, dash
pattern=on 0.30mm off 0.50mm] (60.32,16.24) -- (60.32,27.57); \path[line width=0.15mm, draw=L]
(66.08,31.46) -- (37.12,10.58); \draw(43.41,11.31) node[anchor=base west]{\small  $c_2$}; \path[line
width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm] (44.55,15.97) -- (44.55,19.49); \path[line
width=0.30mm, draw=L] (60.58,15.95) arc (0:0:0.00mm); \path[line width=0.30mm, draw=L] (64.84,15.66)
arc (-5:68:4.40mm); \draw(64.05,20.17) node[anchor=base west]{\small  $\alpha$}; \path[line
width=0.30mm, draw=L, dash pattern=on 0.30mm off 0.50mm] (70.22,38.66) -- (15.92,38.69);
\draw(5.21,39.18) node[anchor=base west]{\small $f(b)$};
\end{tikzpicture}
\caption{ \bf  Метод Ньютона} \label{pic7}
\end{figure}

Перша з них означає, що функція у точці $b$ є додатною і зростає або
є від'ємною і спадає. Друга умова вимагає, щоб знайдена точка не
виходила за межі відрізка. Якщо ці умови не виконуються, то замість
точки $x=b$ можна використовувати іншу границю. Для функції,
наведеної на рис.~\ref{pic8}, умови \eqref{umova} не виконуються у
точках $a$ та $b$, і тому для методу Ньютона потрібно підбирати інший
відрізок.  Загалом, використовуючи цей метод, не обов'язково задавати відрізок
$[\,a,b\,]$, можна шукати розв'язок і навколо однієї точки ($x=b$),
яка буде початковим наближенням. Проте збігатись цей метод при
будь-якому початковому наближенні буде лише у випадку, коли у всіх
точках виконується умова
\[ \frac{|f\cdot f''|}{(f')^2}<1 \;.\]
У протилежному випадку метод буде збігатися лише тоді, коли початкова точка
знаходиться у певному околі розв'язку.

\begin{figure}[t] \centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (33.28,63.14) rectangle +(61.09,29.01);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (35.95,73.73) -- (92.37,73.77);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (92.37,73.77) -- (89.57,74.47) -- (92.37,73.77) --
(89.57,73.07) -- (92.37,73.77) -- cycle; \draw(66.43,84.59) node[anchor=base west]{\small  $f(x)$};
\draw(88.34,70.44) node[anchor=base]{\small  $x$}; \path[line width=0.30mm, draw=L, fill=F]
(42.52,73.66) circle (0.33mm); \path[line width=0.30mm, draw=L, fill=F] (77.96,73.62) circle (0.33mm);
\draw(42.56,74.97) node[anchor=base]{\small  $a$}; \draw(77.18,70.32) node[anchor=base west]{\small
$b$}; \path[line width=0.30mm, draw=L] (36.78,70.57) .. controls (40.76,70.01) and (44.67,69.09) ..
(48.48,67.82) .. controls (52.26,66.55) and (56.38,65.08) .. (59.70,67.22) .. controls (65.19,70.76)
and (63.55,84.08) .. (72.13,82.25) .. controls (73.82,81.89) and (75.03,80.53) .. (76.44,79.54) ..
controls (78.44,78.14) and (80.85,77.50) .. (83.25,77.04) .. controls (86.06,76.49) and (88.91,76.16)
.. (91.77,76.04); \path[line width=0.30mm, draw=L] (35.98,65.14) -- (35.98,90.15); \path[line
width=0.30mm, draw=L, fill=F] (35.98,90.15) -- (35.28,87.35) -- (35.98,90.15) -- (36.68,87.35) --
(35.98,90.15) -- cycle;
\end{tikzpicture}%
\caption{ \bf  Приклад невдалого вибору початкового відрізку для методу Ньютона}\label{pic8}
\end{figure}

Критерієм припинення ітерацій може бути або умова \eqref{b1}, або
\eqref{b4}, де $c_{k}$ --- наближення до розв'язку, отримане на
$k$-му кроці. Фактично, згідно з \eqref{b31},
$c_{k+1}=c_{k}-\displaystyle{\frac{f(c_{k})}{f'(c_{k})}}$\;.


\item
\textbf{\emph{Метод січних}}

За змістом цей метод є симбіозом методів Ньютона та хорд.
Спільними рисами з методом Ньютона є: можливість знаходити розв'язок
 в околі однієї точки;  наступне наближення розраховується на
основі попереднього. Проте, щоб аналітично не обчислювати
похідну використовують різницеву схему,
фактично проводячи хорду через точки $f(c_k)$ та $f(c_{k-1})$ (рис.~\ref{Sichni}).
Тобто, застосовується ітераційний процес, під час якого для
отримання наступного наближення
використовуються результати двох (а не одного, як у вищенаведених методах) попередніх кроків:
\begin{equation}
c_{k+1}=c_k-f(c_k)\cdot\frac{c_k-c_{k-1}}{f(c_k)-f(c_{k-1})}\;.
\label{b5}
\end {equation}
Для здійснення першого кроку потрібні дві початкові точки $c_0$ та $c_1$, проте не
обов'язково, щоб шуканий корінь рівняння знаходився на проміжку між ними.

\begin{figure}
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt, scale=0.9]
\path[line width=0mm] (-1.25,11.08) rectangle +(99.65,56.67);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L] (2.52,23.03) -- (95.53,23.05);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L, fill=F] (95.53,23.05) -- (92.73,23.75) -- (95.53,23.05) --
(92.73,22.35) -- (95.53,23.05) -- cycle; \path[line width=0.3mm, draw=L] (77.88,61.82) .. controls
(76.51,56.36) and (74.15,51.20) .. (70.91,46.59) .. controls (67.33,41.49) and (62.74,37.17) ..
(57.31,34.12) .. controls (47.21,28.44) and (35.30,27.68) .. (24.18,24.55) .. controls (16.95,22.50)
and (10.05,19.44) .. (3.68,15.46); \draw(65,55.81) node[anchor=base west]{\small  $f(x)$}; \path[line
width=0.3mm, draw=L] (2.43,13.95) -- (2.31,64.88); \path[line width=0.3mm, draw=L, fill=F]
(2.31,64.88) -- (1.62,62.08) -- (2.31,64.88) -- (3.02,62.08) -- (2.31,64.88) -- cycle; \draw(88.41,25)
node[anchor=base]{\small  $x$}; \path[line width=0.3mm, draw=L, fill=F] (36.99,22.81) circle (0.4mm);
\path[line width=0.3mm, draw=L, fill=F] (63.13,22.94) circle (0.4mm); \path[line width=0.3mm, draw=L,
fill=F] (74.45,22.94) circle (0.4mm); \path[line width=0.3mm, draw=L, dash pattern=on 0.3mm off
0.72mm] (74.44,52.38) -- (74.38,22.98); \draw(72.83,18) node[anchor=base west]{\small  $c_0$};
\path[line width=0.3mm, draw=L, fill=F] (51.40,22.81) circle (0.4mm); \path[line width=0.22mm, draw=L]
(81.11,61.70) -- (45.85,15.86); \path[line width=0.3mm, draw=L, dash pattern=on 0.3mm off 0.72mm]
(63.15,23.31) -- (63.23,38.27); \path[line width=0.22mm, draw=L] (69.27,42.18) -- (30.61,19.00);
\draw(61.29,18) node[anchor=base west]{\small  $c_1$}; \path[line width=0.3mm, draw=L, dash pattern=on
0.3mm off 0.72mm] (51.34,22.79) -- (51.39,31.47); \draw(49.70,18) node[anchor=base west]{\small
$c_2$}; \draw(35.34,18) node[anchor=base west]{\small $c_3$};
\end{tikzpicture}%
\caption{ \bf  Метод січних} \label{Sichni}
\end{figure}

У знаменнику виразу \eqref{b5} розміщена різниця $f(c_k)-f(c_{k-1})$. Далеко від кореня ця різниця
буде великою, проте при наближенні до кореня вона зменшуватиметься. Як наслідок, при машинних
розрахунках виникає втрата значущих цифр, так зване ``розхитування'' розрахунку. Аби уникнути цього
використовують так званий \emph{прийом Гарвіка}: вибирають не дуже мале значення $\delta_x$ і
проводять ітерації до виконання умови \eqref{b4}; після чого ітерації не припиняють, а повторюють
доти, поки різниця $|\,c_k-c_{k-1}|$ продовжує зменшуватись. Перше збільшення цієї різниці означає, як
правило, початок ``розхитування'', після чого розрахунки припиняють і результат останньої ітерації не
використовують.

\item
\textbf{\emph{Метод простої ітерації}}

У цьому методі рівняння $f(x)=0$ замінюється еквівалентним
\begin{equation}
x=\varphi(x)\,. \label{b6}
\end {equation}
Наприклад, функція $\varphi(x)$ може мати вигляд
\[
\varphi(x)=x-\psi(x)f(x)\,,
\]
де $\psi(x)$ --- довільна неперервна знакостала функція.
Зрозуміло, що коли $x$ буде коренем вихідного рівняння, то рівність
\eqref{b6} також виконуватиметься. В цьому випадку ітераційне
співвідношення має вигляд
\begin{equation}
c_{k+1}=\varphi(c_k)\,, \label{b7}
\end {equation}
і обчислення продовжуються, доки не буде виконуватись
нерівність \eqref{b4}.

Для того, щоб метод збігався, необхідно аби виконувалась умова
$|\,\varphi'(x)|<1$ на всьому інтервалі, де шукається розв'язок. Один
із простих варіантів --- вибрати функцію $\psi(x)$ у вигляді
константи: $\psi(x)=\tau=const$. Якщо на відрізку, де шукається
розв'язок,
\[ 0<m<f'(x)<M \]
($m$ та $M$ --- константи), то для забезпечення збіжності процесу
можна покласти
\[ \tau=\frac{2}{M+m} \,.\]
Для цього методу, окрім \eqref{b4}, існує ще один критерій
припинення ітерацій: відповідь не буде відрізнятися від точного
значення кореня не більше ніж на $\delta_x$, якщо
\begin{equation}
\frac{(c_k-c_{k-1})^2}{|\,2c_{k-1}-c_k-c_{k-2}|}<\delta_x\,.
\end {equation}
Якщо ж у методі простої ітерації покласти $\psi(x)=\frac{1}{f'(x)}$,
то він зведеться до методу Ньютона.

\end{list}

\vspace{.3cm}
\begin{Zavd}\label{Z21}
Написати програму пошуку кореня рівняння\linebreak[4] $f(x)=0$:
\begin{enumerate}[1)]
\setlength{\itemsep}{0.0cm} \setlength{\parsep}{0.0cm}
%\renewcommand{\alph}[1]{\asbuk{#1}}
\item методом ділення навпіл;
\item методом Ньютона;
\item методом хорд;
\item методом січних;
\item методом простої ітерації.
\end{enumerate}
Порівняти отримані результати.
\end{Zavd}

\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

\vspace{.5cm} \emph{Завдання \ref{Z21}}

\begin {enumerate} [i.]
\item У програмі означити функцію, корені якої шукаються, її похідну (для методу Ньютона)
або ітераційну функцію (для методу простої ітерації).

\item Задати величини $\delta$, $\delta_x$ та максимальну кількість ітерацій $N_{iter}$.

\item Визначити інтервал, на якому відбуватиметься пошук розв'язку.
\item Присвоїти нульове значення лічильнику ітерацій $i_{iter}$.

\item Використовуючи один із виразів
 \eqref{b0}, \eqref{b31},  \eqref{b41},  \eqref{b5} або  \eqref{b7}
(залежно від методу) обчислити наступне наближення до розв'язку.
{\label{2.1}}
\item Збільшити лічильник ітерацій на одиницю.

\item Залежно від значень функції $f(x)$ у
точках $a$, $b$ та $c$ змінити інтервал пошуку розв'язку (для методів
дихотомії та хорд).

\item Перевірити виконання:
  \begin{enumerate}[a)]
  \renewcommand{\alph}[1]{\asbuk{#1}}
  \setlength{\itemsep}{0.0cm}
  \setlength{\topsep}{0.0cm}
  \setlength{\partopsep}{0.0cm}
  \setlength{\parsep}{0.0cm}
     \item умови \eqref{b4} (умови \eqref{b2} для методу бісекції);
     \item умови $i_{iter}>N_{iter}$;
     \item умови \eqref{b1}.
  \end{enumerate}
За виконання будь-якої з умов для методів ділення навпіл, дотичних,
хорд та простих ітерацій перейти до п. \ref{2.2}. У протилежному
випадку перейти до п.\ref{2.1}.

Для методу січних при виконанні умови \eqref{b4} використати прийом
Гарвіка. Для цього необхідно запам'ятати різницю наближень, отриманих
у двох останніх ітераціях, перейти до п.\ref{2.1} і в наступних
циклах замість  \eqref{b4} перевіряти, чи не зростає ця різниця. У
решті випадків виконувати дії, аналогічні діям за іншими методами.

\item Вивести на екран результат.{\label{2.2}}

\emph{Примітка.} З метою оцінювання обчислювальної складності методу на екран
можна вивести також значення $i_{iter}$.

\end{enumerate}



\clearpage
\part{Системи лінійних  алгебраїчних рівнянь: методи Гаусса та LU-розвинення}
\addcontentsline{toc}{subsection}{\thepart. Системи лінійних
алгебраїчних рівнянь: \\методи Гаусса та LU-розвинення}

У загальному випадку систему лінійних алгебраїчних рівнянь,  у якій
кількість рівнянь дорівнює кількості невідомих, можна записати у
вигляді

\begin {equation}
\hat A \,\vec{x}=\vec{f}\,,\label{slau1}
\end{equation}
де $\hat A= \left(
\begin{array}{cccc}
 a_{11}&a_{12}&\ldots&a_{1n}\\
 a_{21}&a_{22}&\ldots&a_{2n}\\
 \vdots&\vdots&\ddots&\vdots\\
 a_{n1}&a_{n2}&\ldots&a_{nn}\\
\end {array}
\right)$ --- матриця коефіцієнтів рівнянь,

\vspace{2mm}
 $\vec{f}= \left(
\begin{array}{c}
 f_{1}\\
 f_{2}\\
 \vdots\\
 f_{n}\\
\end {array}
\right)$
--- вектор вільних членів, \vspace{2mm}

$\vec{x}= \left(
\begin{array}{c}
 x_{1}\\
 x_{2}\\
 \vdots\\
 x_{n}\\
\end {array}
\right)$
--- вектор невідомих. \vspace{2mm}

\noindent Система \eqref{slau1} має розв'язок, причому єдиний, за
умови \mbox{$\det{\hat A}\neq0$}, тобто, коли матриця $\hat A$ невироджена.

Розрізняють методи розв'язку таких систем:
  \begin{enumerate}[1)]

  \renewcommand{\alph}[1]{\asbuk{#1}}
     \item прямі --- отримується точний розв'язок (у припущенні відсутності
           помилок округлення) за скінченної кількості арифметичних дій;
     \item ітераційні --- розраховується послідовність
           $\vec{x}_k$ ($k$ -- номер ітерації),
           яка збігається до точного розв'язку при $k\rightarrow\infty$.
  \end{enumerate}
Спочатку розглянемо декілька прямих методів. \vspace{3mm}

\textbf{\emph{Метод Гаусса (або метод виключення Гаусса).}} У  цьому методі
використовується відома властивість, яка полягає у тому, що якщо в
лінійній системі поміняти місцями два рядки, або до одного з рядків
додати інший, помножений на якесь число, то розв'язок системи не
зміниться. Метод Гаусса складається із прямого ходу і зворотнього.
Метою прямого ходу є зведення лінійної системи до верхньої трикутної
(тобто такої, для якої всі $a_{ij}=0$ при $i>j$). Необхідні для цього
дії виконуються за декілька кроків.

\underline{Крок 1}. Виключаємо $x_1$ з усіх рівнянь, починаючи з другого. Для цього до другого
рівняння додаємо перше, домножене на $\left(-\cfrac{a_{21}}{a_{11}}\right)$; до третього --- перше,
домножене на $\left(-\cfrac{a_{31}}{a_{11}}\right)$ і т. д. У результаті отримаємо систему рівнянь
\[
\left\{
 \begin {array} {rcl}
  a_{11}x_1+a_{12}x_2+\ldots+a_{1n}x_n&=&f_1\,; \vspace{1mm}\\
   a_{22}^{(1)}x_2+\ldots+a_{2n}^{(1)}x_n&=&f_2^{(1)}\,;\\
   \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots&\ldots&\ldots\\
   a_{n2}^{(1)}x_2+\ldots+a_{nn}^{(1)}x_n&=&f_n^{(1)}\,,
 \end{array}
\right.
\]
де $ \{ a_{ij}^{(1)} \} $ та $\{f_i^{(1)}\}$ --- матриця коефіцієнтів
рівнянь та вектор вільних членів після першого кроку:
\begin{equation}
\label{krok1} a_{ij}^{(1)}=a_{ij}-\dfrac{a_{i1}}{a_{11}}\cdot
a_{1j}\, , \quad
 f_i^{(1)}=f_i-\dfrac{a_{i1}}{a_{11}}\cdot f_1 \,,\quad
i,\,j=\overline{2, n}\,.
\end{equation}

\underline{Крок 2}. Виключаємо $x_2$ з останніх $(n-2)$ рівнянь. Для цього до третього рівняння
додаємо друге, домножене на $\left(-\cfrac{a_{32}^{(1)}}{a_{22}^{(1)}}\right)$; до четвертого ---
друге, домножене на $\left(-\cfrac{a_{42}^{(1)}}{a_{22}^{(1)}}\right)$ і т. д.
Отримана система рівнянь матиме вигляд
\[
\left\{
 \begin {array} {rcl}
  a_{11}x_1+a_{12}x_2+a_{13}x_3+\ldots+a_{1n}x_n&=&f_1\,; \vspace{1mm}\\
   a_{22}^{(1)}x_2+a_{23}^{(1)}x_3+\ldots+a_{2n}^{(1)}x_n&=&f_2^{(1)}\,; \vspace{1mm}\\
   a_{33}^{(2)}x_3+\ldots+a_{3n}^{(2)}x_n&=&f_3^{(2)}\,,\\

   \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots&\ldots&\ldots\\
   a_{n3}^{(2)}x_3+\ldots+a_{nn}^{(2)}x_n&=&f_n^{(2)}\,,
 \end{array}
\right.
\]
де елементи матриці коефіцієнтів та вектора вільних членів після
другого кроку обчислюються за виразами
\begin{equation}
a_{ij}^{(2)}=a_{ij}^{(1)}-\dfrac{a_{i2}^{(1)}}{a_{22}^{(1)}}\cdot
a_{2j}^{(1)}\, , \quad
 f_i^{(2)}=f_i^{(1)}-\dfrac{a_{i2}^{(1)}}{a_{22}^{(1)}}\cdot f_2^{(1)} \,,\quad
i,\,j=\overline{3, n}\,.
\end{equation}

\[
\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots
%\vdots
\]
\underline{Крок $(n-1)$}. Виключається $x_{n-1}$ з останнього рівняння і в результаті отримується
трикутна система рівнянь
\begin{equation}
\left\{
 \begin {array} {rcl}
  a_{11}x_1+a_{12}x_2+a_{13}x_3+\ldots+a_{1n}x_n&=&f_1\,; \vspace{1mm}\\
   a_{22}^{(1)}x_2+a_{23}^{(1)}x_3+\ldots+a_{2n}^{(1)}x_n&=&f_2^{(1)}\,; \vspace{1mm}\\
   a_{33}^{(2)}x_3+\ldots+a_{3n}^{(2)}x_n&=&f_3^{(2)}\,;\\
   \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots&\ldots&\ldots\\
   a_{nn}^{(n-1)}x_n&=&f_n^{(n-1)}\,.
 \end{array}
\right. \label{g4}
\end{equation}
Після цього розпочинається зворотний хід, під час якого послідовно
визначаються невідомі, починаючи з останньої:
\begin{equation}
\left\{
 \begin {array} {rcl}
  x_n&=&\cfrac{f_n^{(n-1)}}{a_{nn}^{(n-1)}}\,;\\
   \ldots&\ldots&\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\\
  x_k&=&\cfrac{1}{a_{kk}^{(k-1)}}\cdot (f_k^{(k-1)}-a_{k,k+1}^{(k-1)}x_{k+1}-\ldots-a_{kn}^{(k-1)}x_n)\,,\\
  \ldots&\ldots&\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\\
   x_2&=&\cfrac{1}{a_{22}^{(1)}}\cdot (f_2^{(1)}-a_{23}^{(1)}x_{3}-\ldots-a_{2n}^{(1)}x_n) \vspace{1mm}\,,\\
   x_1&=&\cfrac{1}{a_{11}}\cdot (f_1-a_{12}x_{2}-\ldots-a_{1n}x_n) \,.\\
 \end{array}
\right.
\end{equation}

До речі, визначник матриці $\hat A$ можна обчислити як добуток
діагональних елементів матриці \eqref{g4}
\begin{equation}
\det \hat A =a_{11}\times a_{22}^{(1)} \times a_{33}^{(2)} \times
\ldots \times a_{nn}^{(n-1)}.
\end{equation}


При використанні методу Гаусса може виникнути ситуація ділення на нуль
і подальші обчислення унеможливлюються. Ситуація ділення на дуже
мале число також є небажаною, тому що у цьому випадку буде
накопичуватись помилка, пов'язана з машинним округленням. Як наслідок,
частіше на практиці використовують \textbf{\emph{метод Гаусса з вибором
головного елемента}}.

У цьому випадку проводять вибір по стовпцям, а саме: перед
виключенням $x_1$ серед набору $\{a_{\,i1}\}\quad (i=\overline{1,n})$
шукають найбільший за модулем елемент. Якщо для нього $i=k\neq1$, то
міняють місцями перший та $k$-й рядки матриці $\hat A$ і перший та
$k$-й компоненти век\-тора $\vec{f}$ і лише після цього виконують
процедуру виключення першої невідомої (крок 1 прямого ходу). Далі,
перед початком другого кроку, подібним чином знаходять максимальний
за модулем елемент серед набору
 $\{a_{i2}^{(1)}\} \quad (i=\overline{2,n})$, міняють місцями
другий та відповідний рядки і т. д. Якщо на одному із кроків не
вдається знайти у стовці відмінний від нуля елемент, то матриця
системи є виродженою (визначник дорівнює нулю) і розв'язку не існує.

Схожим способом можна реалізувати вибір по рядках: перед
виключенням $x_j$ шукається максимальний за модулем елемент серед
набору $\{a_{ji}^{(j-1)}\} \quad (i=\overline{j,n})$, потім за
необхідності переставляються стовпці матриці $\hat A$ разом із
відповідними компонентами вектора $\vec{x}$ і лише потім
розпочинається домноження та додавання рівнянь (виключення
невідомих). Звичайно, у цьому випадку необхідно запам'ятовувати які
невідомі з якими обмінювались місцями.

Найбільш ефективним буде метод Гаусса з  одночасним вибором головного
елемента по всій матриці (і по стовпцях, і по рядках). Однак
потрібно відслідковувати перестановки стовпців, \mbox{інакше} невідомі
$x_i$ будуть отримані у неправильному порядку. Також, при обчисленні
цим методом детермінанта, слід пам'ятати, що перестановка двох рядків
чи двох стовпців призводить до зміни знака детермінанта на
протилежний.

Отриманий числовими методами розв'язок можна покращити (уточнити).
Запишемо неув'язку розв'язку за рахунок помилок заокруглення
\[ \vec{r}^{(1)}=\vec{f} - \hat A \,\vec{x}^{(1)}\;, \]
де $\vec{x}^{(1)}$
--- отриманий числовий розв'язок. Похибка у першому наближенні
отриманого розв'язку $\boldsymbol{\varepsilon}^{(1)}=\vec{x} -
\vec{x}^{(1)}$ задовольнятиме рівняння
\[
\hat A \boldsymbol{\varepsilon}^{(1)}=\vec{f} - \hat A\,
\vec{x}^{(1)}\, .
\]
Обчисливши праву частину, а потім розв'язавши цю систему рівнянь,
можна отримати $\boldsymbol{\varepsilon}$, а отже і друге
наближення до розв'язку:
\[
\vec{x}^{(2)}=\vec{x}^{(1)} + \boldsymbol{\varepsilon}^{(1)}\, .
\]
Цілком аналогічно можна отримати похибку у другому наближенні
$\boldsymbol{\varepsilon}^{(2)}$ і т. д.


\textbf{\emph{Метод LU-розвинення}.} У цьому випадку матриця $\hat A$
представляється у вигляді добутку двох трикутних матриць:
\begin{equation}
 \hat A = \hat L \cdot \hat U \,,
\end{equation}

\begin{multline}
\left(
\begin{array}{cccc}
 a_{11}&a_{12}&\ldots&a_{1n}\\
 a_{21}&a_{22}&\ldots&a_{2n}\\
 \ldots&\ldots&\ldots&\ldots\\
 a_{n1}&a_{n2}&\ldots&a_{nn}\\
\end{array}
\right) = \\ = \left(
\begin{array}{cccc}
 1&0&\ldots&0\\
 l_{21}&1&\ldots&0\\
 \ldots&\ldots&\ldots&\ldots\\
 l_{n1}&l_{n2}&\ldots&1\\
\end{array}
\right) \cdot  \left(
\begin{array}{cccc}
 u_{11}&u_{12}&\ldots&u_{1n}\\
 0&u_{22}&\ldots&u_{2n}\\
 \ldots&\ldots&\ldots&\ldots\\
 0&0&\ldots&u_{nn}\\
\end{array}
\right) \,.
\end{multline}

Коефіцієнти матриць $\{l_{ij}\}$ та $\{u_{ij}\}$ можна
визначити послідовно. А саме, безпосередньо перемноживши перший рядок
матриці $\hat L$ на матрицю $\hat U$, отримаємо
\[
u_{11}=a_{11}\,, \quad u_{12}=a_{12}\,,\: \ldots, \: u_{1n}=a_{1n} \,.
\]
Після множення другого рядка запишемо
\[ l_{21}=a_{21}/u_{11}\,, \]
\[u_{22}=a_{22}-l_{21}\cdot u_{12} \,,\]
\[ \cdots \cdots\cdots\cdots\cdots\cdots\cdots\]
\[u_{2n}=a_{2n}-l_{21}\cdot u_{1n} \,.\]
За результатом множення третього рядка матриці $\hat L$ на матрицю $\hat
U$ дістанемо
\[ l_{31}=\frac{a_{31}}{u_{11}} \, ,\]
\[ l_{32}=\frac{a_{32}-l_{31}u_{12}}{u_{22}}\, , \,  \ldots\]
У загальному випадку вирази для обчислення коефіцієнтів матриць мають вигляд
\begin{equation}
 \begin {array} {rcl}
  u_{ij}&=&a_{ij}-\sum\limits_{k=1}^{j-1}l_{ik}u_{kj}\,,\quad i\leqslant j\,, \vspace{2mm}\\
   l_{ij}&=&\cfrac{a_{ij}-\sum\limits_{k=1}^{j-1}l_{ik}u_{kj}}{u_{jj}}\,,\quad i>j \,.
 \end{array}
\end{equation}
Відповідно, система \eqref{slau1} зводиться до вигляду
\begin{equation}
(\hat L\, \hat U\,)\, \vec{x}= \vec{f} \,,
\end{equation}
або
\begin{equation}
\hat L\, \vec{V}= \vec{f} \,,\quad \mbox{де} \quad \vec{V}=\hat U
\,\vec{x}\,. \label{LU1}
\end{equation}
З іншого боку, якщо переписати вирази з \eqref{LU1} детальніше, то
вони виглядатимуть так:
\begin{equation}
\left\{
 \begin {array} {l}
  v_1=f_1\,;\\
  l_{21}v_1+v_2=f_2\,;\\
  \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\\
 l_{n1}v_1+l_{n2}v_2+\ldots+v_n=f_n\,,
 \end{array}
\right. \label{LU2}
\end{equation}

\begin{equation}
\qquad \left\{
 \begin {array} {l}
  u_{11}x_1+u_{12}x_2+\ldots+u_{1n}x_n=v_1\,;\\
  u_{22}x_2+\ldots+u_{2n}x_n=v_2\,;\\
  \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\\
  u_{nn}x_n=v_n\,.
 \end{array}
\right. \label{LU3}
\end{equation}
Отже, можна з \eqref{LU2} виразити елементи вектора $\vec{V}$

\begin{equation}
v_1=f_1\,,\quad v_k=f_k-\sum_{j=1}^{k-1}l_{kj}v_j\,,\quad
k=\overline{2,n}\,.
\end{equation}
  Потім, підставивши отримане в \eqref{LU3}, знайти і невідомі:
\begin{equation}
x_k=\frac{1}{u_{kk}}\Bigl(v_k-\sum_{j=k+1}^{n}u_{kj}x_j\Bigr)\,,\quad
k=\overline{(n-1),1}\,.
\end{equation}


Задача про розв'язок системи лінійних рівнянь споріднена до задачі
про пошук оберненої матриці. Так, щоб знайти матрицю, обернену до
$\hat A$, можна розв'язати набір систем рівнянь типу
\[
\hat A \vec{x}_1=\left(
\begin{array} {c}
1\\
0\\
0\\
\vdots\\
0\\
\end{array}
\right) \,,\quad \hat A \vec{x}_2=\left(
\begin{array} {c}
0\\
1\\
0\\
\vdots\\
0\\
\end{array}
\right) \,,\quad \ldots \quad \hat A \vec{x}_n=\left(
\begin{array} {c}
0\\
0\\
0\\
\vdots\\
1\\
\end{array}
\right) \,.
\]
Тоді набір розв'язків $\{\vec{x}_i\}$ утворять стовпці оберненої
матриці $\hat A^{-1}$.




\vspace{.3cm}
\begin{Zavd}\label{Z31}
Написати програму розв’язку системи рівнянь методом Гаусса. За її
допомогою розв’язати систему рівнянь, коефіцієнти якої записані у
файлі у вигляді
\[
\begin{array}{ccccc}
a_{11}&a_{12}&\ldots&a_{1n}&f_1\\
a_{21}&a_{22}&\ldots&a_{2n}&f_2\\
\vdots&\vdots&\ddots&\vdots&\vdots\\
a_{n1}&a_{n2}&\ldots&a_{nn}&f_n\\
\end{array}
\]
\end{Zavd}
\begin{Zavd}\label{Z32}
Написати програму розв’язування системи рівнянь методом Гаусса з
вибором головного елемента.
\end{Zavd}
\begin{Zavd}\label{Z33}
Написати програму пошуку визначника матриці методом Гаусса.
\end{Zavd}
\begin{Zavd}\label{Z34}
Написати програму пошуку оберненої матриці методом Гаусса.
\end{Zavd}




\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

\vspace{.5cm} \emph{Завдання \ref{Z31}---\ref{Z32}}

\begin {enumerate} [i.]
\item \label{gaa1}Відкрити файл.
\item Визначити кількість рівнянь $n$ у системі, порахувавши, наприклад,
кількість рядків у файлі.
\item Залежно від $n$  створити масив необхідного розміру.
\item Перевірити правильність даних у файлі
(кількість чисел у кожному рядку), зчитати дані в масив.
\item \label{gaa3} Закрити файл.

\item \label{gaa4}Провести прямий хід методу Гаусса.
 Для цього присвоїти цілій змінній значення один, $i=0$.

\item \label{ga1} Збільшити значення $i\to i+1$.

\item \label{ga2} Серед множини елементів $\{a_{lk}\}$, ($i\leqslant
 l\leqslant
 n$,
$i\leqslant
 k\leqslant
 n$) знайти найбільший за модулем і визначити номер стовпця $k_{max}$ і номер рядка
$l_{max}$, де він знаходиться.

\item Якщо $l_{max}$ відрізняється від $i$, поміняти
місцями у масиві даних \mbox{$i$-й} та $l_{max}$-й рядки
матриці коефіцієнтів рівняння та відповідні компоненти вектора
вільних членів.

\item \label{ga35} Якщо $k_{max}$ відрізняється
від $i$, поміняти місцями у масиві даних $i$-й та $k_{max}$-й стовпці матриці коефіцієнтів
рівняння. Запам'ятати, які стовпці були переставлені.

\item Якщо $a_{ii}=0$, то вивести на екран напис про те, що розв'язку не
існує та припинити роботу програми.

\item Для всіх коефіцієнтів, які знаходяться в рядку, номер якого більше
$i$, та у стовпці, номер якого більше $i$, а також компонентів вектора вільних членів із номером
більшим за $i$, провести заміну:
\begin{multline*}
a_{lk}\to a_{lk}^{*}=a_{lk}-\dfrac{a_{li}}{a_{ii}}\cdot a_{ik}\, ,
\quad
 f_l\to f_l^{*}=f_l-\dfrac{a_{li}}{a_{ii}}\cdot f_i \,,\quad a_{li}=0\,, \\
l,\,k=\overline{(i+1), n}\,.
\end{multline*}

\item \label{gaa2}Якщо $i<(n-1)$, перейти до п.~\ref{ga1}.

\noindent \emph{Примітка.} При виконанні Завдання \ref{Z31}
пп.~\ref{ga2}--\ref{ga35} пропустити.

\item Провести зворотний хід методу Гаусса. Для цього надати $i$
значення $n$.

\item \label{ga4} Розрахувати значення $i$-ї невідомої за формулою
\begin{equation*}
  \begin{split}
       &x_i=\frac{1}{a_{ii}} \Bigl(f_i-\sum_{k\,=\,i+1}^na_{ik}\,x_{k}\Bigr)\,.
  \end{split}
\end{equation*}
Врахувати, що при $i=n$ кількість доданків у сумі нульова.

\item  Зменшити значення $i\to i-1$.
\item \label{gaa5}Якщо $i>0$, то перейти до п.~\ref{ga4}.

\item Вивести на екран (або у файл) значення всіх невідомих, з урахуванням
 перестановок стовпців, які були виконані, при виборі головного
елемента.

\end{enumerate}



\pagebreak \vspace{.5cm} \emph{Завдання \ref{Z33}}
\begin {enumerate} [i.]
\item Виконати пункти \ref{gaa1}--\ref{gaa2}
алгоритму Завдання \ref{Z31}---\ref{Z32} (окрім дій, які стосуються
компонент вектора вільних членів). Порахувати всі перестановки рядків
і стовпців, які були виконані при виборі головного елемента, і
зберегти їх у змінній $s$.
\item Обчислити визначник матриці за формулою
\begin{equation*}
    \det{\hat A}=(-1)^s\prod_{i=1}^na_{ii}\,.
\end{equation*}
\item Вивести на екран (або у файл) результат.
\end{enumerate}


\vspace{.5cm} \emph{Завдання \ref{Z34}}
\begin {enumerate} [i.]
\item Виконати пункти \ref{gaa1}--\ref{gaa3}
алгоритму \emph{Завдання \ref{Z31}---\ref{Z32}}.

\item Присвоїти цілій змінній $j=1$.
\item \label{gaa7}Присвоїти компонентам вектора вільних членів значення
\begin{equation*}
    f_l=
    \begin{cases}
    1\,,\quad l=j\;;\\
    0\,,\quad l\ne j\,.
    \end{cases}
\end{equation*}

\item Виконати пункти \ref{gaa4}--\ref{gaa5}
алгоритму \emph{Завдання \ref{Z31}---\ref{Z32}}.

\item Запам'ятати отриманий вектор розв'язків як $j$-й стовпець
оберненої матриці.

\item Збільшити значення $j\to j+1$.

\item Якщо $j<n$, то перейти до п.~\ref{gaa7}.
\item Вивести на екран (або у файл) результат.
\end{enumerate}

\clearpage



\part{Системи лінійних  алгебраїчних рівнянь: метод прогонки, ітераційні методи}
\addcontentsline{toc}{subsection}{\thepart. Системи лінійних
алгебраїчних рівнянь: \\метод прогонки, ітераційні методи}

\emph{Метод прогонки (або алгоритм Томаса чи Гельфанда)} .

Це також прямий метод розв'язку системи лінійних алгебраїчних
рівнянь. Він є модифікацією методу Гаусса для часткового випадку
розріджених систем --- систем з тридіагональною матрицею. Сама
система рівнянь виглядає наступним чином: \setlength{\tabcolsep}{3
pt}
\begin{equation}
\left\{
\begin{aligned}
b_1x_1+c_1&x_2              &\hspace{-0.4cm}                       &                           &&\hspace{-0.4cm}=d_1\,,\\
a_2x_1+b_2&x_2+c_2x_3       &\hspace{-0.4cm}                       &                           &&\hspace{-0.4cm}=d_2\,,\\
       a_3&x_2+b_3x_3+c_3x_4&\hspace{-0.4cm}                       &                           &&\hspace{-0.4cm}=d_3\,,\\
          &\hspace{1.3cm}\cdots\cdots&\hspace{-0.4cm}\cdots\cdots\hspace{1.3cm}&\hspace{0.4cm}\cdots\cdots&&\cdots\\
          &                 &\hspace{-0.4cm} a_{n-1}x_{n-2}+b_{n-1}&x_{n-1}+c_{n-1}x_n         &&\hspace{-0.4cm}=d_{n-1}\,,\\
          &                 &\hspace{-0.4cm}                    a_n&x_{n-1}    +b_nx_n         &&\hspace{-0.4cm}=d_n\,.
\end{aligned}
\right.
\end{equation}
Або її можна записати у вигляді \addtocounter{equation}{-1}
\begin{subequations}
\begin{gather}
a_ix_{i-1}+b_ix_i+c_ix_{i+1}=d_i\,,\quad i=\overline{1,n} \,,\label{trd0}\\
a_1=c_n=0\,.\nonumber
\end{gather}
\end{subequations}

Такі системи часто виникають під час розв'язку різних задач
математичного моделювання, наприклад при інтерполяції базовими
сплайнами чи розв'язку диференціальних рівнянь у частинних похідних.
Назва ``тридіагональна'' пов'язана з тим, що у матриці коефіцієнтів
такої системи ненульові члени розміщенні лише на центральній
діагоналі і двох, розташованих поруч з нею.

Давайте спробуємо розв'язати цю систему методом Гаусса, тобто
перетворити матрицю коефіцієнтів до верхньої трикутної. Зазначимо, що
в цьому випадку кожен з $n-1$ кроків складатиметься лише з однієї
дії, а саме під час $k$-го кроку ($k=\overline{1,(n-1)}$) виклюється
$x_k$ з $(k+1)$-го рівняння і з цією метою до цього рівняння
додається $k$-те, домножене на $\left(-\cfrac{a_{k+1}}{b_k^*}\right)$
(де $b_k^*$ --- коефіцієнт перед змінною $x_k$ у $k$-му, вже
зміненому на попередньому кроці, рівнянні). В результаті отримується
система рівнянь
\begin{equation}\label{trd1n}
\left\{
\begin{split}
&b_1x_1+c_1x_2=d_1\,,\\
&b_2^{*}x_2+c_2x_3=d_2^*\,,\\
&\ldots\\
&b_{n-1}^*x_{n-1}+c_{n-1}x_n=d_{n-1}^*\,,\\
&b_n^{*}x_n=d_{n}^*\,,
\end{split}
\right.
\end{equation}
де \addtocounter{equation}{-1}
\begin{subequations}
\begin{equation}\label{trd1na}
b_i^*=b_i-\frac{a_ic_{i-1}}{b_{i-1}^*}\,;\quad
d_i^*=d_i-\frac{d_{i-1}^*a_i}{b_{i-1}^*}\,,\quad i=\overline{2,n}
\end{equation}
\end{subequations}

У рівняннях \eqref{trd1n} можна виразити $x_i$ ($i=\overline{1,n-1}$)
через $x_{i+1}$:

\begin{equation}\label{trd2n}
\begin{split}
&x_i=\frac{d_i^*}{b_i^*}-\frac{c_i}{b_i^*}\,x_{i+1}\,,\quad
i=\overline{1,n-1}\\
&x_n=\frac{d_n^*}{b_n^*}\,.
\end{split}
\end{equation}

B \eqref{trd2n} вважається, що $b_1^*=b_1$, $d_1^*=d_1$. Якщо ввести коефіцієнти
$A_i=-\cfrac{c_i}{b_i^*}$ та $B_i=\cfrac{d_i^*}{b_i^*}$, то з врахуванням \eqref{trd1na} для них можна
записати наступне рекурентне співвідношення

\begin{equation}\label{trd3n}
\begin{split}
&A_1=-\frac{c_1}{b_1}\,,\\
&A_i=-\frac{c_i}{b_i^*}=-\frac{c_i}{{b_i}-\frac{a_ic_{i-1}}{b_{i-1}^*}}
 =-\frac{c_i}{b_i+a_iA_{i-1}}\,,\quad i=\overline{2,(n-1)}\,,\\
&B_1=\frac{d_1}{b_1}\,,\\
&B_i=\frac{d_i^*}{b_i^*}=
\frac{d_i-\frac{a_id_{i-1}^*}{b_{i-1}^*}}{b_i-\frac{a_ic_{i-1}}{b_{i-1}^*}}=
\frac{d_i-a_iB_{i-1}}{b_i+a_iA_{i-1}}\,,\quad i=\overline{2,n}\,.
\end{split}
\end{equation}
В свою чергу, \eqref{trd2n} можна переписати у вигляді
\begin{equation}\label{trd4n}
\begin{split}
&x_n=\frac{d_n-a_nB_{n-1}}{b_n+a_nA_{n-1}}=B_n\,.\\
&x_i=A_i\,x_{i+1}+B_i\,,\quad i=\overline{(n-1),1}
\end{split}
\end{equation}

Таким чином, розв'язок тридіагональної системи рівнянь методом
прогонки розбивається на два етапи:
\begin{list}{\asbuk{N})}{\usecounter{N} %
\setlength{\leftmargin}{0pt}%
\setlength{\topsep}{0.2cm}%
\setlength{\itemindent}{0.5cm}\setlength{\listparindent}{0.5cm}}

%\begin{enumerate} [a)]
%\renewcommand{\alph}[1]{\asbuk{#1}}
\item пряма прогонка, під час якої за допомогою формул
\eqref{trd3n} розраховуються прогоночні коефіцієнти $A_i$ та $B_i$;
\item зворотня прогонка, коли за формулами \eqref{trd4n} розраховуються самі
невідомі.
\end{list}

Для стійкості алгоритму прогонки необхідно, щоб
$|A_1|=\cfrac{c_1}{b_1}<1$, а також виконання діагонального
домінування по рядках $|b_n|\geqslant|a_n|+|c_n|$, причому хоча б для
одного рядка нерівність була строга.

Детермінант матриці коефіцієнтів у цьому випадку, як і у методі
Гаусса, можна знайти як добуток діагональних елементів тридіагональної
матриці:
\begin{equation} \label{Tr1}
\det \hat A =\prod_{i=1}^n b_i^*=-\prod_{i=1}^n \frac{c_i}{A_i}=
\prod_{i=1}^n (b_i+A_{i-1}a_i)\,.
\end{equation}
При використанні виразу \eqref{Tr1} необхідно вважати $A_0=0$.


\vspace{.2cm}\emph{Ітераційні методи}.\nopagebreak

В цьому випадку, як і при розв'язку звичайних алгебраїчних рівнянь
використовується заміна рівняння \eqref{slau1} на еквівалентне:
\begin{equation}
\vec{x}=\hat B\, \vec{x} + \vec{F}\,,
\end{equation}
де $\hat B= \hat E -\tau\hat A$, \quad $\vec{F}=\tau\vec{f}$
\quad($\hat E$ --- одинична матриця, $\tau$ --- скалярний множник).

Тоді розв'язок шукається у вигляді послідовності наближень
\begin{equation}\label{ittt}
\vec{x}^{(k+1)}=\hat B \,\vec{x}^{(k)} + \vec{F}\,,
\end{equation}
причому початкове наближення до розв'язку $\vec{x}^{(0)}$ часто
вибирають у вигляді нульового вектора. Процес збігатиметься, якщо всі
власні значення матриці $\hat B$ за абсолютною величиною менші
одиниці.

Критерієм закінчення ітераційного процесу може виступати виконання
однієї з трьох нерівностей:
\begin{subequations} \label{it1}
\begin{eqnarray}
\Bigl|\,\vec{x}^{(k)}-\vec{x}^{(k-1)} \Bigr|
=\sqrt{\sum_{i=1}^n\left( x_i^{(k)}-x_i^{(k-1)}\right)^2}<\varepsilon\,, \\
\max_{1\leqslant\: i\,\leqslant \:n}\left| x_i^{(k)}-x_i^{(k-1)}\right|<\varepsilon\,, \\
\max_{1\leqslant\: i\,\leqslant \:n}\left|
\frac{x_i^{(k)}-x_i^{(k-1)}}{x_i^{(k)}}\right|<\varepsilon
\,.\label{it13}
\end{eqnarray}
\end{subequations}
При $|x_i|\gg1$ варто застосовувати саме критерій \eqref{it13} .

Підбір скалярного коефіцієнту $\tau$ може бути виконано спираючись на
вигляд $\hat A$. А саме, матрицю коефіцієнтів можна представити у
вигляді
\[
\hat A=\hat L+\hat D+\hat U\,,
\]
де $\hat L$ та $\hat U$ --- нижня та верхня трикутні матриці з
нульовими елементами на головній діагоналі, $\hat D$ --- діагональна
матриця. Тоді можна використовувати або
\begin{equation} \label{yak1}
\hat B=-\hat D^{-1}(\hat L+\hat U)\,,\quad  \vec{F}=\hat D^{-1}
\vec{f}\,,
\end{equation}
що відповідатиме \emph{методу Якобі} (інша назва --- \emph{метод
простої ітерації}), або
\begin{equation} \label{zei1}
\hat B=-(\hat L+\hat D)^{-1}\hat U\,,\quad  \vec{F}=(\hat L+\hat
D)^{-1} \vec{f}\,,
\end{equation}
як це робиться у \emph{методі Зайделя} (\emph{Гаусса-Зайделя}). Якщо
підставити \eqref{yak1} та \eqref{zei1} в \eqref{ittt} і записати
рівності для окремих компонент вектора невідомих, то вони
виглядатимуть більш наочно. А саме, в методі Якобі зв'язок між
компонентами вектора невідомих на різних кроках ітерації описується
рівностями

\begin{equation} \label{yak2}
 \begin{cases}
  x_1^{(k+1)}=-\cfrac{1}{a_{11}}\:(a_{12}x_2^{(k)}+a_{13}x_3^{(k)}+\ldots+a_{1n}x_n^{(k)}-f_1)\,, \vspace{2mm}\\
  x_2^{(k+1)}=-\cfrac{1}{a_{22}}\:(a_{21}x_1^{(k)}+a_{23}x_3^{(k)}+\ldots+a_{2n}x_n^{(k)}-f_2)\,,\\
\cdots\\
  x_n^{(k+1)}=-\cfrac{1}{a_{nn}}\:(a_{n1}x_1^{(k)}+a_{n2}x_2^{(k)}+\ldots+a_{n,n-1}x_{n-1}^{(k)}-f_n)\,,
  \end{cases}
\end{equation}
а в методі Зайделя:
\begin{equation} \label{zei2}
\begin{cases}
  x_1^{(k+1)}=-\cfrac{1}{a_{11}}\:(a_{12}x_2^{(k)}+a_{13}x_3^{(k)}+\ldots+a_{1n}x_n^{(k)}-f_1)\,,\vspace{2mm}\\
  x_2^{(k+1)}=-\cfrac{1}{a_{22}}\:(a_{21}x_1^{(k+1)}+a_{23}x_3^{(k)}+\ldots+a_{2n}x_n^{(k)}-f_2)\,,\\
\cdots\\
  x_n^{(k+1)}=-\cfrac{1}{a_{nn}}\:(a_{n1}x_1^{(k+1)}+a_{n2}x_2^{(k+1)}+\ldots+a_{n,n-1}x_{n-1}^{(k+1)}-f_n)\,.
  \end{cases}
\end{equation}
Тобто, в методі Зайделя при обчисленні чергового наближення $i$-тої
компоненти вектора невідомих використовуються значення інших
компонент з номером, меншим за $i$, отримані на цьому ж кроці і
значення компонент з номером, більшим за  $i$, отримані під час
попереднього наближення. В той час як в методі Якобі використовуються
лише значення, отримані  під час попереднього кроку ітерації.

Таким чином, розв'язок системи рівнянь ітераційним шляхом має
здійснюватись наступним чином:
\begin{list}{\arabic{N})}{\usecounter{N} %
\setlength{\leftmargin}{0pt}%
\setlength{\topsep}{0cm}%
\setlength{\itemsep}{0cm}%
\setlength{\itemindent}{0.5cm}\setlength{\listparindent}{0.5cm}}

\item вибирається початкове наближення до розв'язку, наприклад у
вигляді нульового вектора;
\item спираючись на попереднє наближення за допомогою формул
\eqref{yak2} або \eqref{zei2} розраховується наступне;

\item повторюється попередній пункт доки не буде виконуватись умова
\eqref{it1}.

\end{list}

Для збіжності достатньо  щоб
\begin{equation}
|\,a_{ii}|\geqslant\sum_{j\,\ne \,i}|\,a_{ij}|\,,\quad
i=\overline{1,n}
\end{equation}
і щоб хоча б для одного з рівнянь системи рівність була строга.

Зрозуміло, що необхідно аби $a_{ii}\ne0\,, \: i=\overline{1,n}$. За
умови, що \mbox{$\det {\hat A}\ne0$} цього завжди можна досягти
перестановкою рядків та стовпців.

\vspace{.3cm}
\begin{Zavd}\label{Z41}
Написати програму розв’язку тридіагональної системи рівнянь методом
прогонки.
\end{Zavd}
\begin{Zavd}\label{Z42}
Написати програму розв’язку системи рівнянь методом Зайделя.
\end{Zavd}



\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

В запропонованих алгоритмах вважається, що коефіцієнти систем рівнянь
знаходяться у файлі на диску комп'ютера.


\vspace{.5cm} \emph{Завдання \ref{Z41}} \label{alZ41}
\begin {enumerate} [i.]
\item Відкрити файл.
\item Визначити число рівнянь $n$ у системі, підрахувавши, наприклад,
число рядків у файлі.
\item Залежно від $n$,  створити масив дійсних чисел необхідного розміру.

\emph{Примітка.} Найбільш простий варіант --- створити двовимірний
масив розміром $n\times (n+1)$. Проте більшість комірок масиву будуть
містити нулі, тому для раціонального використання оперативної
пам'яті, особливо при великих $n$, краще створити чотири одновимірних
масиви з $n$ дійсних чисел.
\item Перевірити правильність даних у файлі, зчитати дані в масив.
\item Закрити файл.
\item Користуючись виразами \eqref{trd3n} обчислити
коефіцієнти $A_i$ та $B_i$, $\:i=\overline{1,(n-1)}$.
\item Користуючись виразами \eqref{trd4n} обчислити невідомі.
\item Вивести на екран (або у файл) отримані результати.
\end{enumerate}


\vspace{.5cm} \emph{Завдання \ref{Z42}}



\begin {enumerate} [i.]

\item Відкрити файл.
\item Визначити число рівнянь $n$ у системі, підрахувавши, наприклад,
число рядків у файлі.
\item Залежно від $n$,  створити масив дійсних чисел необхідного розміру.
\item Перевірити правильність даних у файлі, зчитати дані в масив.
\item Закрити файл.

\item Упорядкувати матрицю коефіцієнтів (провести вибір головного
елементу для кожного мінору). Для цього присвоїти цілій змінній
$i=1$. Після чого:
\item \label{zzei1}Збільшити значення $i\to i+1$.
\item Серед множини елементів $\{a_{lk}\}$, ($i\leqslant l\leqslant n$, $i\leqslant k\leqslant n$)
 знайти найбільший за модулем і визначити номер стовпця $k_{max}$ і номер
рядка $l_{max}$ де він знаходиться.

\item Якщо $l_{max}$ відрізняється від $i$, поміняти
місцями у масиві даних \mbox{$i$--тий} та $l_{max}$--тий рядки
матриці коефіцієнтів рівняння та відповідні компоненти вектора
вільних членів.

\item Якщо $k_{max}$ відрізняється
від $i$, поміняти місцями у масиві даних \mbox{$i$--тий} та
$k_{max}$--тий стовпці матриці коефіцієнтів рівняння.

\item Якщо $a_{ii}=0$, то вивести на екран напис, що розв'язок не
існує та припинити роботу програми.

\item Якщо $i<(n-1)$, перейти до п.~\ref{zzei1}

\item Занулити лічильник ітерацій $i_{iter}=0$.

\item Задати максимальне число ітерацій $N_{iter}$ та мінімальне
відхилення двох послідовних ітерацій $\varepsilon$.

\item Присвоїти вектору невідомих початкове наближення:
\begin{equation*}
    x_i=0\,,\quad i=\overline{1,n}\,.
\end{equation*}

\item \label{zzei4}Присвоїти $i=1$.

\item \label{zzei2} Розрахувати наступне наближення $i$--ої змінної:
\begin{equation*}
    x_i\to x_i=-\frac{1}{a_{ii}}\Biggl(\sum_{\substack{j\,=1\\j\,\ne \,i}}^na_{ij}x_j-f_i\Biggr)
\end{equation*}

\item Збільшити $i\to i+1$.

\item Якщо $i\leqslant n$, то перейти до п.~\ref{zzei2}.

\item Збільшити $i_{iter}\to i_{iter}+1$.

\item Якщо $i_{iter}>N_{iter}$, то вивести на екран, що розв'язок не
збігається і припинити роботу програми.

\item Перевірити виконання умови \eqref{it13}. Якщо вона
виконується, то вивести на екран (або у файл) отримані результати;
якщо --- ні, то перейти до п.~\ref{zzei4}.

\end{enumerate}




\clearpage

\part{Інтерполяція за допомогою\\  поліномів Лагранжа та Ньютона}
\addcontentsline{toc}{subsection}{\thepart. Інтерполяція за допомогою
поліномів Лагранжа \\та Ньютона}

Задачу інтерполяції можна сформулювати так: для заданої таблиці
значень $\{x_i,\,y_i=f(x_i)\}$, ($i=\overline{0,n}$) побудувати
інтерполювальну функцію $\varphi(x)$, таку щоб
\begin{equation}\label{lag0}
\varphi\,(x_i)=y_i\,, \quad i=\overline{0,n}\,.
\end{equation}

Точки з координатами $(x_i,y_i)$ називаються вузлами інтерполяції, вони можуть бути, наприклад,
результатом числового розрахунку функції $f(x)$. Графік функції $\varphi(x)$ буде проходити через
вузли (див. рис.~\ref{Inter}). Побудова функції $\varphi(x)$ дає можливість оцінити величину функції
$f(x)$ між вузлами, тобто там, де її точне значення невідоме або його безпосереднє обчислення є
ресурсоємким чи займає багато часу. Очевидно, що розв'язок задачі інтерполяції не є єдиним. Часто
функцію $\varphi(x)$ беруть у вигляді полінома.
\begin{figure}[hb]
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (2.12,7.39) rectangle +(97.82,40.84);
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L] (10.53,15.93) -- (84.06,16.14);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L, fill=F] (84.06,16.14) -- (81.26,16.84) -- (84.06,16.14) --
(81.27,15.44) -- (84.06,16.14) -- cycle; \path[line width=0.3mm, draw=L] (78.98,37.94) .. controls
(76.30,35.98) and (73.10,34.85) .. (69.79,34.70) .. controls (66.49,34.55) and (63.09,35.36) ..
(59.98,34.19) .. controls (55.22,32.40) and (52.97,26.69) .. (48.07,25.23) .. controls (45.25,24.39)
and (42.22,25.19) .. (39.94,27.07) .. controls (37.79,28.84) and (36.32,31.53) .. (33.64,32.35) ..
controls (28.01,34.08) and (24.51,27.65) .. (20.14,23.75) .. controls (17.81,21.67) and (14.89,20.37)
.. (11.79,20.03); \path[line width=0.3mm, draw=L] (10.47,10.50) -- (10.44,43.70); \path[line
width=0.3mm, draw=L, fill=F] (10.44,43.70) -- (9.74,40.90) -- (10.44,43.70) -- (11.14,40.91) --
(10.44,43.70) -- cycle; \path[line width=0.3mm, draw=L, fill=F] (20.07,23.77) circle (0.4mm);
\path[line width=0.3mm, draw=L, fill=F] (40.01,27.04) circle (0.4mm); \path[line width=0.3mm, draw=L,
fill=F] (70.00,34.77) circle (0.4mm); \draw(18.81,11.25) node[anchor=base west]{\small $x_1$};
\path[line width=0.3mm, draw=L, fill=F] (33.75,32.28) circle (0.4mm); \draw(32.50,11.25)
node[anchor=base west]{\small  $x_2$}; \draw(38.76,11.25) node[anchor=base west]{\small  $x_3$};
\path[line width=0.3mm, draw=L, fill=F] (59.96,34.13) circle (0.4mm); \path[line width=0.3mm, draw=L,
fill=F] (48.15,25.18) circle (0.4mm); \draw(46.88,11.25) node[anchor=base west]{\small $x_4$};
\draw(58.71,11.25) node[anchor=base west]{\small  $x_5$}; \path[line width=0.3mm, draw=L]
(20.01,16.60) -- (20.01,15.31); \path[line width=0.3mm, draw=L] (33.73,16.60) -- (33.73,15.31);
\path[line width=0.3mm, draw=L] (40.02,16.60) -- (40.02,15.31); \path[line width=0.3mm, draw=L]
(48.14,16.60) -- (48.14,15.31); \path[line width=0.3mm, draw=L] (60.00,16.60) -- (60.00,15.31);
\path[line width=0.3mm, draw=L] (69.99,16.60) -- (69.99,15.31); \path[] (10.58,23.93) --
(19.86,23.84); \path[line width=0.3mm, draw=L, dash pattern=on 0.3mm off 0.71mm] (10.86,23.75) --
(20.05,23.75); \draw(4.94,22.17) node[anchor=base west]{\small  $y_1$}; \path[line width=0.3mm,
draw=L, dash pattern=on 0.3mm off 0.71mm] (33.60,32.38) -- (10.49,32.47); \draw(5.13,30.71)
node[anchor=base west]{\small  $y_2$}; \draw(68.55,11.25) node[anchor=base west]{\small  $x_6$};
\draw(72.12,39.11) node[anchor=base west]{\small  $\varphi(x)$}; \path[line width=0.21mm, draw=L]
(16.87,28.35) .. controls (17.48,25.48) and (19.80,23.28) .. (22.70,22.83) .. controls (27.51,22.09)
and (31.61,25.88) .. (33.19,30.72) .. controls (33.76,32.46) and (34.32,34.45) .. (36.07,34.80) ..
controls (40.81,35.76) and (38.93,28.78) .. (40.43,24.78) .. controls (41.57,21.72) and (45.32,20.75)
.. (47.32,22.97) .. controls (48.60,24.39) and (48.25,26.48) .. (48.50,28.35) .. controls
(49.32,34.43) and (55.93,37.51) .. (60.18,33.99) .. controls (61.93,32.54) and (62.95,29.88) ..
(65.30,29.92) .. controls (66.82,29.95) and (67.91,31.22) .. (68.71,32.55) .. controls (71.02,36.41)
and (71.91,40.96) .. (71.20,45.41); \path[line width=0.3mm, draw=L, dash pattern=on 0.3mm off 0.71mm]
(20.01,16.15) -- (20.01,23.58); \path[line width=0.3mm, draw=L, dash pattern=on 0.3mm off 0.71mm]
(33.74,16.15) -- (33.74,32.31);
\end{tikzpicture}%
\caption{ \bf  Варіанти інтерполяції для заданих (великі крапки) вузлів} \label{Inter}
\end{figure}


\emph{Метод Лагранжа}.

Для спрощення припустимо, що нам потрібно побудувати інтерполювальний
поліном для таблиці з трьох пар значень --- $(x_0,y_0)$, $(x_1,y_1)$,
$(x_2,y_2)$. Розглянемо функцію
\begin{equation*}
L_0(x)=y_0\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}\,.
\end{equation*}
Ця функція задовольняє умову \eqref{lag0} в точці $x_0$, а в інших вузлах дорівнює нулю, тобто
$L_0(x_0)=y_0$, $L_0(x_1)=0$, $L_0(x_2)=0$. Аналогічно запишемо функції
\begin{equation*}
L_1(x)=y_1\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}\,,
\end{equation*}
\begin{equation*}
L_2(x)=y_2\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\,,
\end{equation*}
які задовольняють умову \eqref{lag0} у двох інших вузлах. Очевидно,
що графік функції $L(x)$, яка є сумою трьох попередніх
\begin{multline*}
L(x)=L_0(x)+L_1(x)+L_2(x)=\\
=y_0\frac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}+y_1\frac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}+\\+
y_2\frac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}\,
\end{multline*}
буде проходити через всі три вузли. Узагальнимо отриману формулу на випадок $(n+1)$ вузла інтерполяції
\begin{equation}\label{lag1}
 L(x)=\sum^{n}_{i=0}y_i\prod^{n}_{\substack{j=0\\ j\,\ne\, i}}
 \frac{(x-x_j)}{(x_i-x_j)}\,.
\end{equation}

Вираз \eqref{lag1} є інтерполювальний поліном Лагранжа, який використовується для інтерполяції на
відрізку $[x_0,x_n]$. Зрозуміло, що це поліном $n$-го порядку.

\emph{Метод Ньютона}.

У методі Ньютона нам знадобиться поняття \emph{скінченних різниць}. Воно використовується у випадку
коли точки $x_i$ рівновіддалені, тобто $x_i-x_{i-1}=h=const \quad (i=\overline{1,n})$. Набір вузлів з
такою властивістю ще називається рівномірною мережею, а величина $h$ --- кроком мережі. Для
нерівномірної мережі розглядаються розділені різниці, але про них ми говорити не будемо.

Розрізняють скінченні різниці вперед і назад.

\emph{Скінченні  різниці вперед} бувають різних порядків, вони можуть
бути обчислені для різних вузлів і описуються наступними виразами.

\noindent Перші різниці (або різниці першого порядку):
\begin{equation}\label{int1}
    \begin{split}
      \Delta^{(1)}\, y_0&=y_1-y_0=f(x_0+h)-f(x_0)\,, \\
      \Delta^{(1)}\, y_1&=y_2-y_1=f(x_0+2h)-f(x_0+h)\,, \\
      \cdots\\
      \Delta^{(1)}\, y_{n-1}&=y_n-y_{n-1}=f(x_0+nh)-f(x_0+(n-1)h)\,.
    \end{split}
\end{equation}
З виразу \eqref{int1} видно, що скінченні різниці вперед першого
порядку можна визначити для всіх вузлів, окрім останнього.

Для других різниць вперед справедливо:
\begin{equation}\label{int2}
    \begin{split}
      \Delta^{(2)}\, y_0&=\Delta^{(1)}\, y_1-\Delta^{(1)}\, y_0\,,\\
      \Delta^{(2)}\, y_1&=\Delta^{(1)}\, y_2-\Delta^{(1)}\, y_1\,,\\
      \cdots\\
      \Delta^{(2)}\, y_{n-2}&=\Delta^{(1)}\, y_{n-1}-\Delta^{(1)}\, y_{n-2}\,.\\
    \end{split}
\end{equation}
Різниці вперед другого порядку можна записати для всіх точок, окрім
двох останніх.

У загальному випадку різниця вперед порядку $k$ описується виразом:
\begin{equation}\label{int3}
      \Delta^{(k)}\, y_i=\Delta^{(k-1)}\, y_{i+1}-\Delta^{(k-1)}\,
      y_i\, ,\quad i=\overline{0,n-k}\,,
\end{equation}
причому $\Delta^{(0)}\, y_i=y_i$ і цю різницю можна записати для
$(n+1-k)$ перших вузлів. Найстарший порядок різниці вперед, який
можна записати для набору $\{x_i,\,y_i\}$, $i=\overline{0,n}$ ---
$n$-ий, причому таку різницю можна записати лише для вузла
$(x_0,y_0)$.

У виразах \eqref{int1}--\eqref{int3} використовується рекурсія: для
обчислення різниці будь-якого порядку необхідно розрахувати різниці
всіх попередніх порядків. Без рекурсії скінченні різниці вперед можна
обчислити за допомогою виразу
\begin{equation}\label{int4}
    \Delta^{(k)}\,y_i=\sum^{k}_{s=0}(-1)^{s+k}\frac{k!}{s!(k-s)!}\,y_{i+s}\,.
\end{equation}

Аналогічно обчислюються \emph{скінченні різниці назад}:
\begin{equation}\label{int41}
    \begin{split}
      \nabla^{(1)}\, y_i&=\nabla^{(0)}\,y_i-\nabla^{(0)}\,y_{i-1}=y_i-y_{i-1}\,,\\
      \nabla^{(2)}\, y_i&=\nabla^{(1)}\, y_i-\nabla^{(1)}\, y_{i-1}=y_i-2y_{i-1}+y_{i-2}\,,\\
      \cdots\\
      \nabla^{(k)}\, y_i&=\nabla^{(n-1)}\, y_i-\nabla^{(n-1)}\,y_{i-1}\,.
    \end{split}
\end{equation}
Подібно до попереднього, для набору вузлів $\{x_i,\,y_i\}$,
$i=\overline{0,n}$ скінченну різницю назад $k$-го порядку можна
записати лише для $(n+1-k)$ останніх точок; можливий найстарший
порядок --- $n$ і таку різницю можна записати лише для точки
$(x_n,y_n)$.

При побудові інтерполювального многочлена Ньютона використовуються
саме скінченні різниці. Так, многочлен Ньютона для інтерполяції
вперед має вигляд
\begin{multline}\label{int5}
    N(x)=y_0+\cfrac{\Delta^{(1)}\,y_0}{h}(x-x_0)+\cfrac{\Delta^{(2)}\,y_0}{2!\,h^2}
    (x-x_0)(x-x_1)+\ldots \\
    +\cfrac{\Delta^{(n)}\,y_0}{n!\,h^n}(x-x_0)(x-x_1)\ldots(x-x_{n-1})\,,
\end{multline}
тобто при його побудові використовуються скінченні різниці вперед від
$0$-го до $n$-го порядку, обчислені для початкової точки
($\Delta^{(i)}y_0\,,\:i=\overline{0,n}$).

 Якщо ввести величину $t=\cfrac{x-x_0}{h}$\,, тоді
\begin{gather*}
    x=x_0+th\,,\\
    \frac{x-x_1}{h}=\frac{(x_0+th)-(x_0+h)}{h}=\frac{th-h}{h}=t-1\,,\\
    \frac{x-x_2}{h}=t-2\,,\\
    \cdots\\
    \frac{x-x_{n-1}}{h}=t-n+1\,,
\end{gather*}
і вираз \eqref{int5} можна записати у вигляді
\addtocounter{equation}{-1}
\begin{subequations}
\begin{multline}
N(x)=y_0+t\cdot\Delta^{(1)}y_0+\frac{t(t-1)}{2!}\cdot\Delta^{(2)}y_0+
\ldots
\\+\frac{t(t-1)\ldots(t-n+1)}{n!}\cdot\Delta^{(n)}y_0\,.\label{int5a}
\end{multline}
\end{subequations}

Многочлен Ньютона також є поліномом $n$-го порядку. Використовуючи формулу \eqref{int5} або
\eqref{int5a} можна інтерполювати функцію $y=f(x)$ на всьому відрізку зміни аргументу $[x_0,x_n]$, але
з точки зору підвищення точності розрахунків більш доцільно її використовувати для обчислення значення
функції у точках лівої половини цього відрізку. Для правої половини краще використовувати
інтерполювальний многочлен Ньютона для інтерполяції назад:
\begin{multline}\label{int6}
    N(x)=y_n+t'\cdot\nabla^{(1)}y_{n}+\frac{t'(t'+1)}{2!}\cdot\nabla^{(2)}y_{n}+
\ldots\\+\frac{t'(t'+1)\ldots(t'+n-1)}{n!}\cdot\nabla^{(n)}y_n\,,
\end{multline}
де
\[ t'=\frac{x-x_n}{h}<0\,.\]

Різні способи побудови многочленів Лагранжа і Ньютона дають тотожні інтерполювальні формули. Але
многочлен Ньютона більш зручно застосовувати у випадку, коли кількість вузлів інтерполяції не є
сталою, а може збільшуватись.
%\vspace{.3cm}
\begin{Zavd}\label{Z51}
Написати програму інтерполяції заданого набору даних за методом
Лагранжа.
\end{Zavd}
\begin{Zavd}\label{Z52}
Написати процедуру обчислення скінченних різниць вперед для заданого
набору даних з використанням рекурсії.
\end{Zavd}
\begin{Zavd}\label{Z53}
Написати процедуру обчислення скінченних різниць вперед для заданих
даних без використання рекурсії.
\end{Zavd}
\begin{Zavd}\label{Z54}
Написати програму інтерполяції заданого набору даних за методом
Ньютона (формула інтерполяції вперед).
\end{Zavd}

\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

В запропонованих алгоритмах вважається, що набір даних знаходиться у текстовому файлі на диску
комп'ютера, а результатом інтерполяції є набір точок $\{x_j,\varphi(x_j)\}$, де
$j=\overline{1,N}\,,\:N\gg n\,,\: x_j\in [x_0,x_n]$, тобто набір значень інтерполювальної функції у
 більшій  кількості точок порівняно з тими, що були дані.


\vspace{.5cm} \emph{Завдання \ref{Z51}}

\begin {enumerate} [i.]
\setlength{\itemsep}{0.0cm}

\item Відкрити файл.
\item Визначити кількість точок, по яких буде проводитись
інтерполяція.

\emph{Примітка.} У формулах, наведених у теоретичній частині,
вважається, що точки нумеруються з нуля, тому кількість точок буде на
одиницю більша ніж $n$.

\item Створити двомірний масив потрібного розміру.
\item Зчитати дані у масив.
\item Закрити файл.

\item Визначити мінімальне $x_{min}$ та максимальне $x_{max}$ значення аргументу.

\item Визначити крок інтерполяції $\delta
x=(x_{max}-x_{min})/N$, де $N$ --- кількість точок, у яких буде розраховане значення інтерполювальної
функції (рекомендовано вибирати $N\geqslant100$).
\item Присвоїти цілій змінній $k=0$.

\item Відкрити файл для внесення результатів.

\item \label{llag1}Обчислити абсцису $x_k^{int}$ інтерполювальної
 функції  $x_k^{int}=x_{min}+\delta x\cdot k$.

\item Якщо $x_k^{int}>x_{max}$, то перейти до п.~\ref{llag2}.

\item Користуючись формулою \eqref{lag1} обчислити ординату
інтерполювальної функції $y_k^{int}=L(x_k^{int})$.

\item Записати значення $(x_k^{int},y_k^{int})$ у файл.

\item Збільшити значення $k\to k+1$.

\item Перейти до п.~\ref{llag1}.

\item \label{llag2} Закрити файл з результатами.

Отриманий файл зі значеннями інтерполювальної функції можна використати
для побудови графіку, наприклад за допомогою програми
\emph{OriginPro}.

\end{enumerate}

\vspace{.5cm} \emph{Завдання \ref{Z52}} \vspace{.3cm}


\begin{tabular}{cp{7cm}}
  Назва функції: \\\textit{FD}\,()& --- повертає дійсну величину.\\
  Аргументи функції:  \\$\{x_i,y_i\}\,,\: i=\overline{0,n}\:$ &--- набір точок
   (двомірний масив дійсних чисел) для
  інтерполяції або вказівник на них;\\
    $k$&--- порядок різниці; \\
    $J$&--- номер точки, для якої шукається різниця. \\
\end{tabular}

 Назва функції є абревіатурою від слів finite difference (скінченна різниця).  Тоді для \textit{FD}\:$\bigl(\{x_i,y_i\},k,J\bigr)$ послідовність
 виконання може бути описана дуже коротко:
\begin {enumerate} [i.]
\setlength{\itemsep}{0.0cm} \setlength{\parsep}{0.0cm}
\item Перевірити коректність отриманих даних, тобто виконання
умов $k\geqslant0$, $J\geqslant0$ та $(k+J)\leqslant n$. У протилежному випадку вивести відповідне
повідомлення, $\text{\textit{FD}}=0$ і припинити виконання функції.
\item \begin{multline*}
\text{\textit{FD}}\bigl(k,J\bigr)=\\=
\begin{cases}
y_J\,,&\mbox{якщо }k=0\\
\text{\textit{FD}}\bigl(k-1,J+1\bigr)-\text{\textit{FD}}\bigl(k-1,J\bigr)\,,& \mbox{якщо
}k\geqslant1\,.
\end{cases}
\end{multline*}
\end{enumerate}


\vspace{.5cm} \emph{Завдання \ref{Z54}}
\begin {enumerate} [i.]
%\setlength{\itemsep}{0.0cm} \setlength{\parsep}{0pt}
\item Відкрити файл.
\item Визначити кількість точок, по яких буде проводитись
інтерполяція.

\emph{Примітка.} У формулах, наведених у теоретичній частині,
вважається, що точки нумеруються з нуля, тому кількість точок буде на
одиницю більша ніж $n$.

\item Створити двомірний масив потрібного розміру.
\item Зчитати дані у масив.
\item Закрити файл.

\item Перевірити рівномірність мережі, порівнюючи різницю $(x_1-x_0)$ з іншими різницями
$(x_{i+1}-x_i)$  для $i=\overline{1,(n-1)}$. Якщо рівномірність не
виконується, то вивести відповідне повідомлення і завершити виконання
програми.

\emph{Примітка.} При порівнянні дійсних чисел врахувати похибку машинного округлення.

\item Знайти крок мережі $h$.

\item Визначити мінімальне $x_{min}$ та максимальне  $x_{max}$ значення аргументу.


\item Визначити крок інтерполяції $\delta
x=(x_{max}-x_{min})/N$, де $N$ --- кількість точок, у яких буде розраховане значення інтерполювальної
функції (рекомендовано вибирати $N\geqslant100$).

\item Присвоїти цілій змінній $k=0$.

\item Відкрити файл для внесення результатів.

\item \label{newt1}Обчислити абсцису $x_k^{int}$ інтерполювальної
 функції $x_k^{int}=x_{min}+\delta x\cdot k$.

\item Якщо $x_k^{int}>x_{max}$, то перейти до п.~\ref{newt2}.

\item Користуючись формулою \eqref{int5} (або \eqref{int5a}) обчислити ординату
інтерполювальної функції $y_k^{int}$. У даному випадку доцільно створити
окрему функцію для розрахунку кінцевих різниць, а також обчислювати
наступний доданок у сумі, використовуючи значення попереднього.

\item Записати значення $(x_k^{int},y_k^{int})$ у файл.

\item Збільшити значення $k\to k+1$.

\item Перейти до п.~\ref{newt1}.

\item \label{newt2} Закрити файл з результатами.

Отриманий файл зі значеннями інтерполювальної функції можна використати
для побудови графіку, наприклад за допомогою програми
\emph{OriginPro}.
\end{enumerate}


\clearpage

\part{Інтерполяція сплайнами}
\addcontentsline{toc}{subsection}{\thepart. Інтерполяція сплайнами}

У випадку, коли кількість вузлових точок  $\{x_i,\,y_i=f(x_i)\}$,
$i=\overline{0,n}$ є досить великою, то при інтерполяції методом
Лагранжа або Ньютона буде отримано поліном високого порядку (степінь
полінома на  одиницю менша за кількість точок). Відомо, що у такому
випадку часто спостерігаються значні розходження між значеннями
функції $f(x)$ та значеннями інтерполювальних поліномів. Щоб уникнути
цього можна використовувати не один поліном високого порядку, а набір
поліномів низького (часто 3--го) порядку, кожен з яких
використовується для інтерполяції $f(x)$ в різних частинах
$[x_0,x_n]$. Набір таких поліномів називається сплайном.

\emph{Кубічні сплайн--функції.}

Це спеціальним чином побудовані многочлени 3--го порядку; вони
являють собою модель тонкого стержня з пружного матеріалу, який, якщо
його закріпити у двох сусідніх вузлах інтерполяції і задати в цих
точках кути нахилу, набуде форму для мінімізації своєї потенціальної
енергії.

В даному випадку кожен проміжок між сусідніми  вузлами інтерполюється
своїм поліномом 3-го порядку, тобто цих поліномів на одиницю менше
ніж точок, по яким відбувається інтерполяція. Аналітичний вигляд для
кожного з них є наступним
\begin{equation}\label{spl1}
    S_i(x)=a_i+b_i(x-x_{i-1})+c_i(x-x_{i-1})^2+d_i(x-x_{i-1})^3\,,
\end{equation}
\[
x_{i-1}\leqslant x\leqslant x_i\,, \quad i=\overline{1,n}\,.
\]

Для того, щоб записати їх явний вигляд необхідно знати $4n$ величин: $\{a_i,b_i,c_i,d_i\}$. Рівняння,
для визначення цих невідомих можна отримати виходячи з наступних умов. По-перше, повинні
задовольнятися співвідношення (\ref{lag0}), тобто
\[
S_i(x_{i-1})=y_{i-1}\,,\quad S_i(x_i)=y_i\,,
\]
а отже
\begin{equation}\label{spl2}
    a_i=y_{i-1}\,,
\end{equation}
\begin{equation}\label{spl3}
    a_i+b_ih_i+c_ih_i^2+d_ih_i^3=y_i\,,
\end{equation}
де $h_i=x_i-x_{i-1}$ і мережа не обов'язково рівномірна, $i=\overline{1,n}$. Записавши вирази
\eqref{spl2} та \eqref{spl3} маємо $2n$ рівнянь. По-друге, для того щоб сплайн був гладким, перші та
другі похідні повинні бути неперервними для внутрішніх вузлів інтерполяції:
\[
S'_i(x_i)=S'_{i+1}(x_i)\,,\quad S''_i(x_i)=S''_{i+1}(x_i)\,,\quad
i=\overline{1,(n-1)}\,,
\]
тобто для $i=\overline{1,(n-1)}$
\begin{equation}\label{spl4}
    b_{i+1}=2h_ic_i+3h_i^2d_i+b_i\,,
\end{equation}
\begin{equation}\label{spl5}
    c_{i+1}=c_i+3h_id_i\,.
\end{equation}
Вирази \eqref{spl4} та \eqref{spl5} --- це ще $(2n-2)$ рівняння. Дві умови (рівняння), яких не
вистачає, визначаються значеннями першої та другої похідних у точках $x_0$ та $x_n$. Найчастіше
використовують умову вільних кінців сплайну
\begin{align*}
  S''_1(x_0) &= 0\,, \\
  S''_n(x_n) &= 0\,,
\end{align*}
тобто
\begin{gather}
  c_1=0 \label{spl6}\,,\\
  c_n+3h_nb_n=0\,. \label{spl7}
\end{gather}
Але можуть бути й інші граничні умови. Наприклад, можуть бути задані
кути нахилу сплайну в крайніх точках:
\begin{align*}
  S'_1(x_0) &= k_1, \\
  S'_n(x_n) &= k_2,
\end{align*}
тоді \addtocounter{equation}{-2}
\begin{subequations}
\begin{equation}
b_1=k_1\,,
\end{equation}
\end{subequations}
\begin{subequations}
\begin{equation}
 b_n+2h_nc_n+3h_n^2d_n=k_2\,,
\end{equation}
\end{subequations}
або ж
\begin{align*}
  S''_1(x_0) &= m_1\,, \\
  S''_n(x_n) &= m_2\,,
\end{align*}
і тоді

\addtocounter{equation}{-2}
\begin{subequations}
\begin{equation}\addtocounter{equation}{1}
2c_1=m_1\,,
\end{equation}
\end{subequations}

\begin{subequations}
\begin{equation}\addtocounter{equation}{1}
 2c_n+6h_nd_n=m_2\,,
\end{equation}
\end{subequations}
де $k_1$\,, $k_2$\,, $m_1$\,, $m_2$ --- задані константи.


Систему рівнянь \eqref{spl2}--\eqref{spl7} можна розв'язувати,
наприклад, методом Гаусса, але зручніше та економічніше звести її
спочатку до тридіагональної і застосувати метод прогонки. Для цього
спочатку  з \eqref{spl2} знаходимо коефіцієнти
\begin{equation}\label{nnn1}
    a_i=y_{i-1}\,,\quad i=\overline{1,n}\,.
\end{equation}


З \eqref{spl5} можна виразити
\begin{equation}\label{nnn2}
    d_i=\cfrac{c_{i+1}-c_i}{3h_i}\,,\quad
i=\overline{1,n}\,,
\end{equation}
і підставивши в \eqref{spl3} отримати
\begin{equation}\label{nnn3}
    b_i=\frac{y_i-y_{i-1}}{h_i}-\frac{h_i}{3}\,(c_{i+1}+2c_i)\,,
\end{equation}
після чого, використовуючи \eqref{spl5} матимемо
\begin{multline}\label{nnn4}
    h_{i-1}\,c_{i-1}+2(h_{i-1}-h_i)\,c_i+h_i\,c_{i+1}=\\=3\left(
    \frac{y_i-y_{i-1}}{h_i}-\frac{y_{i-1}-y_{i-2}}{h_{i-1}}\right)
    \,,\quad i=\overline{2,n}\,.
\end{multline}
Доповнивши останню систему якоюсь парою умов з набору
\eqref{spl6}--\eqref{spl7} отримаємо тридіагональну систему з $(n+1)$
рівняння.

Таким чином, для обчислення інтерполювальної функції в точці $x$ ($x\in [x_0,x_n]$) необхідно спираючись
на вузлові точки за допомогою виразів \eqref{nnn1}--\eqref{nnn4} обчислити набір коефіцієнтів
$\{a_i,b_i,c_i,d_i\}$, визначити на якому інтервалі знаходиться шукана точка $x$ (визначити номер $k$,
щоб $x_k\leqslant  x\leqslant  x_{k-1}$) і тоді скористатися виразом \eqref{spl1} з відомими
значеннями $a_k$, $b_k$, $c_k$, $d_k$ та $x_{k-1}$.

\vspace{.2cm}\emph{Базові сплайни}.

$B$--сплайном, або базовим сплайном порядку $(N-1)$ відносно вузлів
$\{x_i\}_{i=k}^{k+N}$ називається функція
\begin{equation}\label{bspl1}
    B_{N-1,k}(x)=B_{N-1}(x_k,x_{k+1},\ldots x_{k+N},x)=N\cdot
    \sum_{i=k}^{k+N}\frac{(x_i-x)_{max}^{N-1}}
    {\prod\limits^{k+N}_{\substack{j\,=\,k \\ j\,\ne\,i}}
    (x_i-x_j)}\,,
\end{equation}
де
\begin{equation*}
    (x_i-x)_{max}^{N-1}=
    \begin{cases}
    (x_i-x)^N\,,&x\leqslant x_i\\
    0\,,&x>x_i
    \end{cases}.
\end{equation*}
Якщо мережа рівномірна, тобто
\begin{equation*}
    x_{k+i}=x_k+i\,h\,,
\end{equation*}
де $h$ --- крок, то при $N=4$ формулу для кубічного $B$--сплайну, максимум якого розташований у точці
$x=x_k$, можна записати у вигляді:
\begin{multline}\label{bspl2}
    B_{3,k}(x)=\\=
    \begin{cases}
      0\,,& \hspace{-2mm}x\leqslant x_{k-2}\\
      \cfrac{(x-x_{k-2})^3}{6h^4}\,,&\hspace{-2mm}x_{k-2}\leqslant x \leqslant x_{k-1} \vspace{2mm}\\
      \cfrac{1}{6h}+\cfrac{x-x_{k-1}}{2h^2}+\cfrac{(x-x_{k-1})^2}{2h^3}
      -\cfrac{(x-x_{k-1})^3}{2h^4}\,,&\hspace{-2mm}x_{k-1}\leqslant x\leqslant x_{k} \vspace{2mm}\\
      \cfrac{1}{6h}+\cfrac{x_{k+1}-x}{2h^2}+\cfrac{(x_{k+1}-x)^2}{2h^3}
      -\cfrac{(x_{k+1}-x)^3}{2h^4}\,, & \hspace{-2mm}x_{k}\leqslant x\leqslant x_{k+1} \vspace{2mm}\\
      \cfrac{(x_{k+2}-x)^3}{6h^4}\,,&\hspace{-2mm}x_{k+1}\leqslant x \leqslant x_{k+2} \vspace{2mm}\\
      0\,,& \hspace{-2mm}x\geqslant x_{k+2}\,.
    \end{cases}
\end{multline}

\begin{figure}
  \center
%  \includegraphics [width=0.8\textwidth]{fig2}\\
\begin{tikzpicture}[yscale=4,scale=1.2]
 \draw[line width=0.3mm] plot file{B.txt};
 \draw[line width=0.3mm,->] (-3,0)--(3,0) node[anchor= south east]{\small $x$};
  \draw[line width=0.3mm,->] (-3,0)  -- (-3,0.8) node[anchor= north west]{\small$B_{3,k}$} ;
  \foreach \x in {-2,-1}
     \draw[line width=0.3mm,yscale=0.25] (\x cm,0 cm ) -- +(0 cm ,-0.05 cm) node[anchor=north]{\small$ x_{k\x}$};
      \draw[line width=0.3mm,yscale=0.25] (0 cm,0 cm ) -- +(0 cm ,-0.05 cm) node[anchor=north]{\small$ x_{k}$};
  \foreach \x in {1,2}
     \draw[line width=0.3mm,yscale=0.26] (\x cm,0 cm ) -- +(0 cm ,-0.05 cm) node[anchor=north]{\small$ x_{k+\x}$};
\end{tikzpicture}
  \caption{ \bf  Вигляд кубічного базового сплайну}\label{bspl3}
\end{figure}
\noindent Тобто, якщо звичайні сплайни проводять лише на інтервалі між двома сусідніми точками, то
базові --- на відрізку, який охоплює декілька точок з сукупності тих, по яким проводиться
інтерполяція. У випадку кубічного базового сплайну він буде відмінним від нуля на інтервалі між
п'ятьма послідовними точками, тобто шириною чотири кроки; причому на кожному з чотирьох підінтервалів
(між сусідніми вузлами) він описується своєю функцією. Вигляд функції \eqref{bspl2} наведено на
рис.~\ref{bspl3}.

Іншою відмінністю базових сплайнів від звичайних є те, що значення інтерполювальної функції визначається
не одним многочленом, а сумою декількох. А саме, лінійною комбінацією всіх \emph{В}-сплайнів,
проведених на сукупностях вузлів, які знаходяться в околі шуканої точки. Відповідно, для виконання
умови \eqref{lag0} необхідно, щоб
\begin{equation}\label{bspl4}
    \beta_{i-1}\,B_{i-1}(x_i)+\beta_i\,B_i(x_i)+\beta_{i+1}\,B_{i+1}(x_i)=y_i\,,\quad
    i=\overline{1,(n-1)}\,,
\end{equation}
де $\beta_i$ --- коефіцієнти інтерполяції, а індекс біля кубічного $B$--сплай\-ну вказує на точку
$x_i$, де він досягає свого максимального значення (порівняно з \eqref{bspl2} індекс ``3'' опущений
задля скорочення запису). Тобто, необхідно підібрати такі значення коефіцієнтів інтерполяції, щоб
значення функції $f(x_i)=y_i$, яка інтерполюється,  збігалося з сумою значень трьох базових сплайнів,
центрованих на точці, що є аргументом функції $x_i$, та двох сусідніх, домножених на ці коефіцієнти.
Для крайніх точок діапазону розглядаються лише два доданки:
\begin{equation}\label{bspl5}
    \begin{split}
      \beta_0\,B_0(x_0)+\beta_1\,B_1(x_0) & =  y_0\,, \\
      \beta_{n-1}\,B_{n-1}(x_n)+\beta_n\,B_n(x_n) & = y_n\, .
    \end{split}
\end{equation}
Фактично, \eqref{bspl4} та  \eqref{bspl5} --- це тридіагональна система рівнянь, розв'язоком якої є
коефіцієнти $\{\beta_i\}$. Після цього значення інтерполювальної функції у довільній точці
розраховується, як сума значень базових сплайнів у цій точці:
\begin{equation}\label{bspl6}
    B(x)=\sum_{i=0}^{n}\beta_i\,B_i(x)\,.
\end{equation}
Кількість ненульових доданків у цій сумі для будь-якої точки не перевищуватиме чотири.



\vspace{.3cm}
\begin{Zavd}\label{Z61}
Написати програму кубічної сплайн-інтерполяції для заданого набору
рівновіддалених вузлів  (використовувати кубічні базові сплайни).
\end{Zavd}

 \vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

\vspace{.5cm} \emph{Завдання \ref{Z61}} \nopagebreak У цій програмі
доцільно створити окрему функцію, яка б обчислювала значення
кубічного \emph{В}--сплайну $B_i(x)$, центрованого в точці $x_i$
відповідно до виразу \eqref{bspl2}. Аргументами цієї функції можуть
бути вказівник на набір вузлів, номер вузла $i$ відносно якого
будується сплайн та саме значення $x$.
\begin {enumerate} [i.]
\item Зчитати дані з файлу у двовимірний масив та визначити кількість точок,
по яким буде відбуватися інтерполяція, враховуючи, що вони
нумерюються починаючи з нуля.

\item Перевірити рівномірність мережі, порівнюючи різницю $(x_1-x_0)$ з іншими різницями
$(x_{i+1}-x_i)$  для $i=\overline{1,(n-1)}$.

\item Визначити коефіцієнти інтерполяції $\{\beta_i\}$. Для цього
знайти коефіцієнти тридіагональної матриці:
    \begin{alignat*}{2}
     % \nonumber to remove numbering (before each equation)
       d_i &= y_i\,, &\quad i&=\overline{0,n}\,,\\
       a_i &= B_{i-1}(x_i)\,, & i&=\overline{1,n}\,,\\
       b_i &= B_i(x_i)\,,& i&=\overline{0,n}\,,\\
       c_i &= B_{i+1}(x_i)\,,& i&=\overline{0,(n-1)}\,,\\
       a_0&=0\,, c_{n}=0\,,
     \end{alignat*}
де зміст величин $a_i$, $b_i$, $c_i$ та $d_i$  такий самий як і в \eqref{trd0}, ст.~\pageref{trd0}.
\item Розв'язати отриману систему рівнянь
відносно $\{\beta_i\}$ (див. алгоритм до \emph{Завдання \ref{Z41}.}
на ст.~\pageref{alZ41}).

\item Визначити мінімальне $x_{min}$ та максимальне $x_{max}$ значення аргументу.

\item Визначити крок інтерполяції $\delta
x=(x_{max}-x_{min})/N$, де $N$ --- кількість точок, у яких буде розраховане значення інтерполювальної
функції (рекомендовано вибирати $N\geqslant100$).
\item Присвоїти цілій змінній $k=0$.

\item Відкрити файл для внесення результатів.

\item \label{bsp1}Обчислити абсцису $x_k^{int}$ інтерполювальної
 функції $x_k^{int}=x_{min}+\delta x\cdot k$.

\item Якщо $x_k^{int}>x_{max}$, то перейти до п.~\ref{bsp2}.

\item Користуючись формулою \eqref{bspl6}  обчислити ординату
інтерполювальної функції $y_k^{int}$.

\item Записати значення $(x_k^{int},y_k^{int})$ у файл.

\item Збільшити значення $k\to k+1$.

\item Перейти до п.~\ref{bsp1}.

\item \label{bsp2} Закрити файл з результатами.


\end{enumerate}


\clearpage


\part{Апроксимація}
\addcontentsline{toc}{subsection}{\thepart. Апроксимація}

При інтерполяції використовувалася  умова (\ref{lag0}) рівності
значень інтерполювальної та вихідної функцій у вузлах інтерполяції.
Проте у випадку, коли вихідні дані є результатом експерименту слід
враховувати можливість наявності похибок (випадкових чи
систематичних). Тому використовувати умову (\ref{lag0}) не завжди
доцільно.

Задача апроксимації може бути сформульована трохи інакше: за набором
значень $\{x_i,\,y_i\}\,,i=\overline{0,n}$ знайти залежність
$y=\varphi(x)$, значення якої у точках $x_i$ мало відрізняються від
$y_i$. Фактично,  мова йде про знаходження емпіричної формули.

Розв'язок цієї задачі складається з двох етапів:
\begin{enumerate}[1)]
  \item підбір загального вигляду функції; \label{ap1}
  \item визначення оптимальних значень параметрів, які містить ця
  функція. \label{ap2}
\end{enumerate}
Перший етап може бути виконано або спираючись на фізичні міркування
(якщо відома залежність, якою мають описуватись отримані значення),
або на геометричні --- за виглядом отриманої кривої. Один з
найпростіших варіантів --- апроксимація набору значень лінійною
функцією
\begin{equation}\label{ap3}
    \varphi=a_1x+a_0\,.
\end{equation}
де $a_1$ та $a_0$ --- сталі, величини яких залежать від
$\{x_i,\,y_i\}$. Доречі, до лінійної залежності отримані
експериментально дані можна звести, використовуючи, наприклад, не
декартові координати. Зокрема, температурна залежність провідності
$\sigma$ власного напівпровідника описується формулою
$\sigma=\sigma_0\exp\left(\cfrac{E_g}{2kT}\right)$ (де $E_g$ ---
ширина забороненої зони, $k$ --- стала Больцмана, $T$ ---
температура, $\sigma_0$ --- стала). Якщо експериментально виміряти
залежність $\sigma(T)$, то лінійну апроксимацію отриманих даних можна
застосувати у випадку, коли по осі ординат відкладати натуральний
логарифм провідності, а по осі абсцис --- величину, обернену до
температури: $\ln\sigma=\ln\sigma_0+\cfrac{E_g}{2k}\,\cfrac{1}{T}$.

В загальному ж випадку
\begin{equation}\label{ap4}
    y=\varphi(x,a_0,a_1,\ldots a_m)\,,
\end{equation}
де $a_i$ --- невідомі постійні параметри, а функція $\varphi$ далеко
не обов'язково є поліноміальною. Кількість параметрів не має
перевищувати число точок, по яких відбувається апроксимація; як
правило, кількість параметрів набагато менша.

Щодо підбору значень параметрів, тобто виконання завдання другого
етапу, то тут існує декілька методів.

\emph{Метод середніх}. В цьому випадку параметри знаходять з умови,
що середнє відхилення від точок, по яким проводять апроксимацію має
бути рівним нулеві:
\begin{equation}\label{ap5}
    \sum^{_n}_{i=0}\varepsilon_{i}=\sum^{_n}_{i=0}\,[\,\varphi(x_i,a_0,a_1,\ldots
    a_m)-y_i]=0\,.
\end{equation}
Звичайно, одного цього рівняння недостатньо для визначення $(m+1)$
величин і тому різні $\varepsilon_i$ групують у $(m+1)$ рівнянь.
Наприклад:

\begin{equation}
\left\{
\begin{split}
\varepsilon_0+\varepsilon_1+\varepsilon_2&=0\,,\\
\varepsilon_3+\varepsilon_4+\varepsilon_5+\varepsilon_6&=0\,,\\
\cdots\\
\varepsilon_{n-1}+\varepsilon_n&=0\,.
\end{split}
\right.
\end{equation}

\begin{figure}
\center
\begin{tikzpicture}
 \draw[line width=0.3mm,->] (-1,0)--(7,0) node[anchor= south east]{\small $x$};
 \draw[line width=0.3mm,->] (-1,0)--(-1,5) node[anchor= north west]{\small $y$};
 \draw[line width=0.3mm,]  (-1,0.5)--(7,4.5) node[above left] {\small$\varphi(x)$};

 \foreach \x/\xtext in { 0.8/1, 1.9/2,  3.95/4,  5.9/6}{
  \coordinate (A) at (\x,0);
  \draw(A) -- +(0,-0.05) node[anchor=north]{\small$x_{\xtext}$};
 \coordinate (A') at ($ (A) + (0,5)$);
  \filldraw (intersection of A--A' and -1,0.5--7,4.5) -- node[right]{\small$\varepsilon_{\xtext}$} ++(0,2*\x-2*\xtext) circle (1 pt);
}
 \foreach \x/\xtext in {0.1/0, 3.4/3, 5.1/5}{
  \coordinate (A) at (\x,0);
  \draw(A) -- +(0,-0.05) node[anchor=north]{\small$x_{\xtext}$};
 \coordinate (A') at ($ (A) + (0,5)$);
  \filldraw (intersection of A--A' and -1,0.5--7,4.5) -- node[left]{\small$\varepsilon_{\xtext}$} ++(0,2*\x-2*\xtext) circle (1 pt);
}
\end{tikzpicture}
\caption{ \bf  Апроксимація лінійною функцією}
\end{figure}


\emph{Метод найменших квадратів}. В цьому методі записується сума
квадратів відхилень
\begin{equation}\label{ap6}
S=
\sum^{_n}_{i=0}\varepsilon_{i}^2=\sum^{_n}_{i=0}\,[\,\varphi(x_i,a_0,a_1,\ldots
    a_m)-y_i]^2\,
\end{equation}
і параметри знаходяться з умови мінімізації цієї суми:
\begin{equation}\label{ap7}
    \frac{\partial S}{\partial a_0}=0\,, \quad\frac{\partial S}{\partial a_1}=0\,,
    \ldots \quad \frac{\partial S}{\partial a_m}=0\,.
\end{equation}
Наприклад, при лінійній апроксимації за формулою \eqref{ap3} сума
квадратів відхилень матиме вигляд
\begin{equation}\label{ap8}
    S=\sum_{i=0}^{n}\,[\,a_0+a_1x_i-y_i]^2
\end{equation}
і прирівнявши до нуля частинні похідні виразу \eqref{ap8} по
параметрам $a_0$ та $a_1$ можна отримати вирази для їх визначення:
\begin{equation}\label{ap9}
    \begin{split}
      a_0 & =  \cfrac{\sum\limits_ix_i^2\sum\limits_iy_i-\sum\limits_ix_i\sum\limits_i
      x_iy_i}{n\sum\limits_ix_i^2-\left(\sum\limits_ix_i\right)^2}\,, \vspace{2mm} \\
      a_1 & =  \cfrac{n\sum\limits_ix_iy_i-\sum\limits_ix_i\sum\limits_iy_i}
      {n\sum\limits_ix_i^2-\left(\sum\limits_ix_i\right)^2}\,.
    \end{split}
\end{equation}
У випадку апроксимації параболою
\begin{equation}\label{ap10}
    \varphi(x)=a_0+a_1x+a_2x^2
\end{equation}
сума квадратів відхилень матиме вигляд
\begin{equation}\label{ap11}
    S=\sum_{i=0}^{n}\,[\,a_0+a_1x_i+a_2x_i^2-y_i]^2
\end{equation}
і після знаходження частинних похідних отримується система рівнянь
\begin{equation}\label{ap12}
    \left\{
    \begin{split}
      na_0+a_1\sum\limits_ix_i+a_2\sum\limits_ix_i^2-\sum\limits_iy_i & =  0 \vspace{1mm}\\
      a_0\sum\limits_ix_i+a_1\sum\limits_ix_i^2+a_2\sum\limits_ix_i^3-\sum\limits_ix_iy_i & =  0 \vspace{1mm}\\
      a_0\sum\limits_ix_i^2+a_1\sum\limits_ix_i^3+a_2\sum\limits_ix_i^4-\sum\limits_ix_i^2\,y_i & =
      0\,.
    \end{split}
    \right.
\end{equation}
Її розв'язок дозволяє отримати явні вирази для параметрів:
\begin{multline*}
     a_2  =
     D^{-1}\times\left\{\,\sum\limits_iy_i\,x_i^2\,\cdot\left[n\sum\limits_ix_i^2-\left(\sum\limits_ix_i\right)^2\right]-\right.\\-
      \sum\limits_ix_i^3\cdot\left[n\sum\limits_ix_iy_i-\sum\limits_ix_i\cdot\sum\limits_iy_i\right]+
      \\
      \left.+\sum\limits_ix_i^2\cdot\left[\sum\limits_ix_iy_i\cdot\sum\limits_ix_i-\sum\limits_ix_i^2\cdot\sum\limits_iy_i\right]\right\}\,,
\end{multline*}
\begin{multline*}
      a_1  =
      D^{-1}\times\left\{\, \sum\limits_ix_i^4\, \cdot\left[n\sum\limits_ix_i\,y_i- \sum\limits_ix_i \cdot \sum\limits_iy_i \right]-\right.\\-
       \sum\limits_ix_i^2\,y_i \cdot\left[n\sum\limits_ix_i^3- \sum\limits_ix_i \cdot \sum\limits_ix_i^2 \right]+ \\
      \left.+ \sum\limits_ix_i^2 \cdot\left[ \sum\limits_ix_i^3 \cdot \sum\limits_iy_i - \sum\limits_ix_i^2 \cdot \sum\limits_ix_iy_i \right]\right\}\,,
\end{multline*}
\begin{multline}\label{ap13}
      a_0  =
      D^{-1}\times\left\{\, \sum\limits_ix_i^4\, \cdot\left[ \sum\limits_iy_i \cdot \sum\limits_ix_i^2 - \sum\limits_ix_i \cdot \sum\limits_ix_i\,y_i \right]-\right.\\-
       \sum\limits_ix_i^3 \cdot\left[ \sum\limits_iy_i \cdot \sum\limits_ix_i^3
      - \sum\limits_ix_i\,y_i \cdot \sum\limits_ix_i^2 \right]+\\+
      \left. \sum\limits_iy_i\,x_i^2 \cdot\left[ \sum\limits_ix_i^3 \cdot \sum\limits_ix_i -\left(\sum\limits_ix_i^2\right)\,^2\right]\right\}\,,
\end{multline}
 де величина $D$ описується виразом
\begin{multline*}\label{ap14}
 D  = \left\{\,\sum\limits_ix_i^4\,\cdot\left[n\sum\limits_ix_i^2-\left(\sum\limits_ix_i\right)^2\right]-
       \sum\limits_ix_i^3 \cdot\left[n\sum\limits_ix_i^3-\right.\right.\\ \left.\left.- \sum\limits_ix_i \cdot \sum\limits_ix_i^2 \right]+
       \sum\limits_ix_i^2 \cdot\left[ \sum\limits_ix_i^3 \cdot \sum\limits_ix_i -\left(\sum\limits_ix_i^2\right)\,^2\right]\right\}\,.
 \end{multline*}
Існує також модифікований  метод найменших квадратів у якому
враховується те, що різні точки, на основі яких проходить
апроксимація, можуть мати різну важливість. В цьому випадку сума
квадратів відхилень записується у вигляді
\begin{equation}\label{ap15}
S= \sum^{_n}_{i=0}\,\Bigl\{\omega_i\,[\,\varphi(x_i,a_0,a_1,\ldots
    a_m)-y_i]^2\Bigr\}\,,
\end{equation}
де $\omega_i$ --- вагові коефіцієнти, а дії для знаходження
параметрів залишаються такими самими. Чим важливіша точка, тим більше
значення вагового коефіцієнта для неї. Наприклад, якщо помилка
визначення функції в точці $(x_i,y_i)$ дорівнює $\Delta_i$, то можна
прийняти, що $\omega_i=1/\Delta_i\,$. У випадку, коли всі дані мають
однакову відносну похибку, то вдалим вибором вагових коефіцієнтів є
$\omega_i=1/y_i$ --- так звана статистична вага.


\vspace{.3cm}
\begin{Zavd}\label{Z71}
Написати програму апроксимації  поліномом першого порядку за методом
найменших квадратів. За її допомогою обчислити коефіцієнти поліному
для даних, що знаходяться у файлі.
\end{Zavd}
\begin{Zavd}\label{Z72}
Написати програму апроксимації  поліномом другого порядку за методом
найменших квадратів. За її допомогою обчислити коефіцієнти поліному
для даних, що знаходяться у файлі.
\end{Zavd}

\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

\vspace{.5cm} \emph{Завдання \ref{Z71}}


\begin {enumerate} [i.]
\item Зчитати дані з файлу у двовимірний масив та визначити кількість точок,
по яким буде відбуватися апроксимація, враховуючи, що вони
нумерюються починаючи з нуля.
\item Користуючись виразами \eqref{ap9} (або \eqref{ap13}) обчислити
коефіцієнти апроксимуючого поліному. У даному випадку доцільно
спочатку розрахувати потрібні суми, а потім вже знайти параметри
прямої (параболи).

\item Вивести на екран (або у файл) отримані результати.
\end{enumerate}

Файл із вхідними даними можна використати для побудови точок, а
отримані параметри для побудови прямої (параболи), наприклад за
допомогою програми \textit{OriginPro}.  Також у цій програмі можна
безпосередньо виконати апроксимацію за допомогою вбудованих функцій і
порівняти знайдені коефіцієнти.



\clearpage

\part{Числове інтегрування}
\addcontentsline{toc}{subsection}{\thepart. Числове інтегрування}

Формули числового інтегрування функції однієї змінної називаються квадратурними формулами. Якщо
функція задано таблично (своїми значеннями у певних точках, тобто набором $\{x_i,y_i=f(x_i)\}$,
($i=\overline{0,n}$), то найбільш ефективними будуть квадратурні формули інтерполювального типу. І
навпаки, коли відомо аналітичний вигляд під\-інте\-граль\-ної функції, але неможливо здійснити саме
інтегрування, то найбільш ефективними будуть квадратурні формули типу Гаусса (у цьому випадку вибір
розташування вузлових точок знаходиться у руках того, хто проводить обчислення і це дозволяє вибрати
їх таким чином, щоб мінімізувати кількість обчислень). Розглянемо ці методи детальніше.

Якщо необхідно знайти інтеграл
\begin{equation}\label{chi1}
    I=\int_a^bf(x)\,dx\,,
\end{equation}
то найбільш загальна постановка задачі числового інтегрування --- замінити вираз \eqref{chi1} сумою:
\begin{equation}\label{chi2}
    I=\sum_{i=0}^nC_i\,f(x_i)+R\approx\sum_{i=0}^nC_i\,f(x_i)\,,
\end{equation}
де $C_i$ --- вагові коефіцієнти, $f(x_i)$ --- значення функції у вузлових точках $x_i$, $R$ ---
похибка.

Один з варіантів вирішення цієї задачі --- замінити $f(x)$
інтерполювальним многочленом:
\begin{equation}\label{chi3}
    f(x)=\sum_{i=0}^nf(x_i)\,\chi_i(x)+r_n(x)\,,
\end{equation}
де поліноми $\chi_i(x_i)=1$ та $\chi_i(x_j)=0$ при $j\neq i$ , а
$r_n(x)$
--- залишковий член інтерполяції (похибка заміни). Тоді
\begin{equation}\label{chi4}
    \begin{split}
      C_i & =  \int\limits_a^b\chi_i(x)\,dx \vspace{1mm}\\
      R & =  \int\limits_a^br_n(x)\,dx\,.
    \end{split}
\end{equation}
\emph{Формули Ньютона-Котеса}.

\nopagebreak Якщо для інтерполяції функції $f(x)$ використовується
поліноми Лагранжа, тобто
\begin{equation}\label{chi5}
    f(x)=\sum_{i=0}^nf(x_i)\prod_{\substack{j\,=\,0\\
    j\,\ne\,i}}\frac{(x-x_j)}{(x_i-x_j)}\,,
\end{equation}
то отримані в результаті квадратурні формули називаються формулами
Ньютона-Котеса. Залежно від того, якого порядку поліноми
використовуються, виділяють декілька методів.

\begin{figure}[b]
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (17.04,67.52) rectangle +(118.18,36.34); \draw(57.15,98.95) node[anchor=base
west]{\small  $f(x)$};
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L] (22.70,71.26) -- (22.72,101.86);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (22.72,101.86) -- (22.02,99.07) -- (22.72,101.86) --
(23.42,99.06) -- (22.72,101.86) -- cycle; \draw(68.11,75.58) node[anchor=base]{\small  $x$};
\draw(27.49,70.19) node[anchor=base]{\small  $a\!=\!x_0$}; \draw(62.38,70.32) node[anchor=base
west]{\small  $x_7\!=\!b$}; \draw(19.04,86.51) node[anchor=base west]{\small  $y_0$}; \path[line
width=0.15mm, draw=L, dash pattern=on 2.00mm off 1.00mm] (31.54,86.63) -- (22.73,86.50);
\definecolor{F}{rgb}{0.753,0.753,0.753}
\path[line width=0.15mm, draw=L, fill=F] (28.92,73.59) rectangle +(4.84,12.98); \path[line
width=0.15mm, draw=L, fill=F] (33.76,73.59) rectangle +(3.37,17.19); \path[line width=0.15mm, draw=L,
fill=F] (37.13,73.59) rectangle +(6.38,19.58); \path[line width=0.15mm, draw=L, fill=F] (43.51,73.59)
rectangle +(3.93,19.93); \path[line width=0.15mm, draw=L, fill=F] (47.44,73.59) rectangle
+(6.88,17.82); \path[line width=0.15mm, draw=L, dash pattern=on 2.00mm off 1.00mm] (36.32,90.71) --
(22.71,90.75); \draw(19.04,90.51) node[anchor=base west]{\small  $y_1$}; \path[line width=0.15mm,
draw=L, fill=F] (54.32,73.59) rectangle +(4.00,17.12); \path[line width=0.15mm, draw=L, fill=F]
(58.32,73.59) rectangle +(4.98,19.15); \draw(34.27,70.29) node[anchor=base]{\small  $x_1$};
\draw(37.81,70.29) node[anchor=base]{\small  $x_2$}; \path[line width=0.30mm, draw=L] (69.44,101.49)
.. controls (66.81,99.37) and (64.17,97.25) .. (61.54,95.13) .. controls (58.02,92.29) and
(54.02,89.44) .. (49.70,90.55) .. controls (46.96,91.26) and (44.86,93.57) .. (42.06,94.03) ..
controls (38.40,94.63) and (35.25,92.11) .. (32.43,89.66) .. controls (30.10,87.63) and (27.75,85.61)
.. (25.39,83.61); \draw(43.77,70.29) node[anchor=base]{\small  $x_3$}; \draw(48.03,70.29)
node[anchor=base]{\small  $x_4$}; \draw(55.20,70.29) node[anchor=base]{\small  $x_5$};
\draw(59.07,70.29) node[anchor=base]{\small  $x_6$}; \path[line width=0.30mm, draw=L] (22.75,73.53) --
(72.10,73.60);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (72.10,73.60) -- (69.30,74.30) -- (72.10,73.60) --
(69.30,72.90) -- (72.10,73.60) -- cycle; \draw(19.04,94) node[anchor=base west]{\small  $y_2$};
\path[line width=0.15mm, draw=L, dash pattern=on 2.00mm off 1.00mm] (39.89,93.12) -- (22.81,93.10);
\draw(113.37,98.95) node[anchor=base west]{\small  $f(x)$}; \path[line width=0.30mm, draw=L]
(78.11,71.26) -- (78.13,101.86); \path[line width=0.30mm, draw=L, fill=F] (78.13,101.86) --
(77.43,99.07) -- (78.13,101.86) -- (78.83,99.06) -- (78.13,101.86) -- cycle; \draw(124.33,75.58)
node[anchor=base]{\small  $x$}; \draw(74.45,90) node[anchor=base west]{\small  $y_0$};
\definecolor{F}{rgb}{0.753,0.753,0.753}
\path[line width=0.15mm, draw=L, fill=F] (85.14,73.59) rectangle +(4.82,17.15); \path[line
width=0.15mm, draw=L, fill=F] (89.84,73.59) rectangle +(3.49,19.54); \path[line width=0.15mm, draw=L,
fill=F] (93.35,73.59) rectangle +(6.37,20.03); \path[line width=0.15mm, draw=L, fill=F] (99.74,73.59)
rectangle +(3.92,17.93); \path[line width=0.15mm, draw=L, fill=F] (103.67,73.59) rectangle
+(6.74,17.15); \path[line width=0.15mm, draw=L, dash pattern=on 2.00mm off 1.00mm] (89.77,90.78) --
(78.08,90.73); \draw(74.45,92.5) node[anchor=base west]{\small  $y_1$}; \path[line width=0.15mm,
draw=L, fill=F] (110.47,73.66) rectangle +(4.01,19.05); \path[line width=0.15mm, draw=L, fill=F]
(114.47,73.59) rectangle +(4.86,22.84); \draw(90.50,70.29) node[anchor=base]{\small  $x_1$};
\draw(94.03,70.29) node[anchor=base]{\small  $x_2$}; \path[line width=0.30mm, draw=L] (125.66,101.49)
.. controls (123.03,99.37) and (120.40,97.25) .. (117.77,95.13) .. controls (114.25,92.29) and
(110.25,89.44) .. (105.92,90.55) .. controls (103.18,91.26) and (101.08,93.57) .. (98.28,94.03) ..
controls (94.62,94.63) and (91.47,92.11) .. (88.65,89.66) .. controls (86.32,87.63) and (83.97,85.61)
.. (81.61,83.61); \draw(99.99,70.29) node[anchor=base]{\small  $x_3$}; \draw(103.97,70.29)
node[anchor=base]{\small  $x_4$}; \draw(111.42,70.29) node[anchor=base]{\small  $x_5$};
\draw(115.29,70.29) node[anchor=base]{\small  $x_6$}; \path[line width=0.30mm, draw=L] (78.08,73.67)
-- (128.32,73.60);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.30mm, draw=L, fill=F] (128.32,73.60) -- (125.52,74.30) -- (128.32,73.60) --
(125.52,72.90) -- (128.32,73.60) -- cycle; \draw(74.45,95) node[anchor=base west]{\small  $y_2$};
\path[line width=0.15mm, draw=L, dash pattern=on 2.00mm off 1.00mm] (93.34,93.62) -- (78.08,93.64);
\path[line width=0.15mm, draw=L, dash pattern=on 2.00mm off 1.00mm] (89.92,93.13) -- (78.15,93.02);
\draw(83.54,70.19) node[anchor=base]{\small  $a\!=\!x_0$}; \draw(118.36,70.32) node[anchor=base
west]{\small  $x_7\!=\!b$};
\end{tikzpicture}%
\caption{ \bf  Метод прямокутників із центруванням на лівій і правій границі відрізку (нерівномірна
мережа)} \label{pramokutnik}
\end{figure}


\emph{Метод прямокутників}. В цьому випадку на кожному відрізку,  на
які розбивається область інтегрування вузловими точками, функція
$f(x)$ інтерполюється поліномом нульового степеня:
\begin{equation}\label{chi6}
    f(x_i)=y_i\,,\quad i=\overline{0,n}\,.
\end{equation}
Якщо позначити відстань між сусідніми точками $h_i=x_i-x_{i-1}$,
\mbox{$i=\overline{1,n}$}, то інтеграл \eqref{chi1} можна обчислити
використовуючи центруван\-ня на лівій границі відрізку
\begin{subequations}
\begin{equation}
    I\approx h_1y_0+h_2y_1+\ldots+h_ny_{n-1}=\sum_{i=1}^{n}h_i y_{i-1}\,,\label{chi7}
\end{equation}
\end{subequations}
на правій \addtocounter{equation}{-1}
\begin{subequations}\label{chi8}
\begin{equation}\addtocounter{equation}{1}
    I\approx h_1y_1+h_2y_2+\ldots+h_ny_n=\sum_{i=1}^{n}h_i y_{i}\,,
\end{equation}
\end{subequations}
чи в середніх точках \addtocounter{equation}{-1}
\begin{subequations}\label{chi9}
\begin{eqnarray}\addtocounter{equation}{2}
   & I\approx \sum\limits_{i\,=1}^nh_i\,f(x_{i-1/2})\,, \label{chi10}\\
 \nonumber  & \mbox{де}\quad
 x_{i-1/2}=\frac12(x_{i-1}+x_i)\,,\:i=\overline{1,n}\,.
\end{eqnarray}
\end{subequations}
Останній варіант найпоширеніший і дає найточніший результат серед
всіх трьох. Якщо крок між вузловими точками однаковий ($h_i=h=const$)
то (\ref{chi9}c) перетворюється на \addtocounter{equation}{-1}
\begin{subequations}\label{chi11}
\begin{equation}\addtocounter{equation}{2}
    I\approx h\cdot\sum\limits_{i\,=1}^nf(x_{i-1/2})\,.
    \tag{\ref{chi10}$\,'$}
\end{equation}
\end{subequations}
Найпростіший варіант застосування методу прямокутників для обчислення
інтегралу --- це використання значення функції лише в одній вузловій
точці:
\begin{equation}\label{chi12}
    I=\int_a^bf(x)\,dx\approx(b-a)\,f\Bigl(\frac{a+b}{2}\Bigr)\,.
\end{equation}
Зрозуміло, що це модифікація виразу (\ref{chi9}c).


\emph{Метод трапецій}. В цьому наближенні на відрізку $[x_k,x_{k+1}]$
функція $f(x)$ замінюється інтерполювальним поліномом Лагранжа першого
порядку:
\begin{equation}\label{tr1}
    f(x)=f(x_k)+\frac{f(x_{k+1})-f(x_k)}{x_{k+1}-x_k}\,(x-x_k)\,.
\end{equation}
Тоді
\begin{equation}\label{tr2}
    I\approx\frac12\sum_{i=1}^n\,h_i\,(y_{i-1}+y_i).
\end{equation}
У випадку сталого кроку цей вираз перетворюється на
\begin{equation}\label{tr3}
    I\approx h \cdot\left(\frac{y_0+y_n}2+\sum_{i=1}^{n-1}y_i\right)\,.
    \tag {\ref{tr2}$\,'$}
\end{equation}
В найпростішому випадку використовуються лише значення функції у
точках на границях інтервалу, де шукається інтеграл:
\begin{equation}\label{tr4}
    I\approx\frac{b-a}2\:\bigl[\,f(a)+f(b)\bigr]\,.
\end{equation}
\begin{figure}[tb]
\centering
\begin{tikzpicture}[x=1.00mm, y=1.00mm, inner xsep=0pt, inner ysep=0pt, outer xsep=0pt, outer ysep=0pt]
\path[line width=0mm] (-6.77,-3.09) rectangle +(99.33,56.18); \draw(60,45.49) node[anchor=base
west]{\small  $f(x)$};
\definecolor{L}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L] (1.98,2.68) -- (2.01,50.00);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L, fill=F] (2.01,50.00) -- (1.31,47.20) -- (2.01,50.00) -- (2.71,47.20)
-- (2.01,50.00) -- cycle; \draw(78.38,8) node[anchor=base]{\small  $x$}; \draw(10.41,1)
node[anchor=base]{\small  $a\!=\!x_0$}; \draw(66.50,1) node[anchor=base west]{\small  $x_7\!=\!b$};
\draw(-3,26.26) node[anchor=base west]{\small  $y_0$}; \path[line width=0.23mm, draw=L, dash
pattern=on 3.09mm off 1.55mm] (13.40,26.29) -- (2.08,26.29); \path[line width=0.23mm, draw=L, dash
pattern=on 3.09mm off 1.55mm] (20.66,32.75) -- (2.08,32.73); \draw(-3,32.44) node[anchor=base
west]{\small  $y_1$}; \draw(21.78,1) node[anchor=base]{\small  $x_1$}; \draw(29.42,1)
node[anchor=base]{\small  $x_2$}; \draw(37.22,1) node[anchor=base]{\small  $x_3$}; \draw(45.00,1)
node[anchor=base]{\small  $x_4$}; \draw(52.71,1) node[anchor=base]{\small $x_5$}; \draw(60.55,1)
node[anchor=base]{\small  $x_6$}; \draw(-3,37.61) node[anchor=base west]{\small $y_2$}; \path[line
width=0.23mm, draw=L, dash pattern=on 3.09mm off 1.55mm] (28.88,37.52) -- (2.08,37.43);
\definecolor{F}{rgb}{0.753,0.753,0.753}
\path[line width=0.23mm, draw=L, fill=F] (13.57,6.24) -- (13.46,26.33) -- (21.39,32.85) --
(21.38,6.24) -- cycle; \path[line width=0.23mm, draw=L, fill=F] (21.28,6.35) -- (21.28,33.07) --
(28.88,37.52) -- (28.99,6.35) -- cycle; \path[line width=0.23mm, draw=L, fill=F] (28.99,6.35) --
(28.88,37.52) -- (36.48,36.98) -- (36.37,6.35) -- cycle; \path[line width=0.23mm, draw=L, fill=F]
(36.48,6.35) -- (36.37,36.98) -- (44.19,33.07) -- (44.19,6.35) -- cycle; \path[line width=0.23mm,
draw=L, fill=F] (44.19,6.35) -- (44.19,32.96) -- (51.90,32.42) -- (51.90,6.35) -- cycle; \path[line
width=0.23mm, draw=L, fill=F] (51.90,6.35) -- (51.90,32.53) -- (59.72,36.22) -- (59.61,6.35) -- cycle;
\path[line width=0.23mm, draw=L, fill=F] (59.72,6.35) -- (59.61,36.22) -- (67.54,42.41) --
(67.43,6.35) -- cycle; \path[line width=0.3mm, draw=L] (76.14,49.42) .. controls (72.07,46.14) and
(68.01,42.86) .. (63.94,39.59) .. controls (58.50,35.20) and (52.31,30.79) .. (45.62,32.51) ..
controls (41.39,33.60) and (38.14,37.17) .. (33.81,37.88) .. controls (28.16,38.81) and (23.28,34.92)
.. (18.93,31.13) .. controls (15.32,27.99) and (11.69,24.87) .. (8.04,21.77); \path[line width=0.3mm,
draw=L] (2.08,6.41) -- (84.54,6.30);
\definecolor{F}{rgb}{0,0,0}
\path[line width=0.3mm, draw=L, fill=F] (84.54,6.30) -- (81.74,7.00) -- (84.54,6.30) -- (81.74,5.60)
-- (84.54,6.30) -- cycle;
\end{tikzpicture}%
\caption{ \bf  Метод трапецій (рівномірна мережа)} \label{trapec}
\end{figure}


\emph{Метод парабол (або Сімпсона)}. Якщо інтервал $[a,b\,]$ розбити
на парну кількість відрізків і на кожному з інтервалів $[x_0,x_2]$,
$[x_2,x_4]$, \dots $[x_{n-2},x_n]$ інтерполювати функцію многочленом
Лагранжа $2$--го порядку, то у випадку рівномірної мережі для
інтегралу отримаємо:
\begin{equation}\label{sim1}
    I\approx\frac{h}3\,\bigl[y_0+4(y_1+y_3+\ldots+y_{n-1})+2(y_2+y_4+\ldots+y_{n-2})+y_n\bigr]\,.
\end{equation}
Інший варіант --- використовувати точки посередині відрізків
(аргументи з напівцілими індексами); тоді кількість відрізків, на які
розбивається інтервал інтегрування, може бути не лише парною:
\begin{equation}\label{sim2}
    I\approx\frac{h}6\,\bigl[y_0+4(y_{1/2}+y_{3/2}+\ldots+y_{n-1/2})+2(y_1+y_2+\ldots+y_{n-1})+y_n\bigr]\,.
\end{equation}
Найпростіший випадок числового інтегрування за допомогою методу Сімпсона описується виразом
\begin{equation}\label{sim3}
    I\approx \frac{h}6\,\left[\,f(a)+4\,f\left(\frac{a+b}2\right)+f(b)\right]\,.
\end{equation}

\emph{Квадратури Гаусса}

Розв'язуючи задачу пошуку такого розташування вузлів $x_i$ і такого
значення вагових коефіцієнтів $C_i$ , щоб $r_n(x)=0$ (див. вирази
\eqref{chi2}--\eqref{chi3}) для поліномів щонайбільшого степеня,
К.Ф.~Гаусс показав, що якщо у ролі $n$ вузлів використати нулі
поліномів Лежандра $P_{n+1}(x)$ степеня $(n+1)$, а вагові коефіцієнти
обчислювати згідно з виразом
\begin{equation*}
    C_i=\int_{-1}^1\prod_{\substack{k\,=\,0 \\ k\,\ne\,i}}^n
    \frac{x-x_k}{x_i-x_k}\,dx\,,
\end{equation*}
то квадратурна формула
\begin{equation}\label{kvg1}
    \int_{-1}^1f(x)\,dx=\sum_{i=0}^n\,C_i\,f(x_i)
\end{equation}
буде точною для поліномів степеня $(2n+1)$.

Іншими словами, порядок числового  інтегрування з використанням
квадратур Гаусса може бути таким.

\begin{list}{\arabic{N})}{\usecounter{N} %
\setlength{\leftmargin}{0pt}%
\setlength{\topsep}{0.2cm}%
\setlength{\itemindent}{0.5cm}\setlength{\listparindent}{0.5cm}}

  \item Вибирати кількість вузлів (припустимо, їх буде $n+1$).
  \item \label{kv1}Обчислити розташування вузлів $\{\tilde{x}_i\}\,,\:i=\overline{0,n}$
  на відрізку $[-1,1]$ як нулі полінома Лежандра степеня
  $n+1$.
  Рекурентна формула для поліномів Лежандра має вигляд:
\begin{equation}\label{kvg2}
    \begin{split}
     P_{-1}&=0\,,\\
     P_0&=1\,,\\
     (k+1)\,P_{k+1}(x)&=(2k+1)\cdot x\cdot P_k(x)-k\cdot P_{k-1}(x)\,.
    \end{split}
\end{equation}
  Для знаходження нулів можна використати метод Ньютона або якийсь
  інший метод розв'язку алгебраїчних рівнянь.

\item \label{kv2}Обчислити вагові коефіцієнти за допомогою виразу
  \begin{equation}\label{kvg3}
    C_i=\frac{2}{(1-\tilde{x}_i)^2\cdot\left[\cfrac{d}{dx}P_{n+1}(\tilde{x}_i)\right]^2}\,.
  \end{equation}

Загалом, задача сформулювана у пунктах \ref{kv1} та \ref{kv2} є
стандартною і тому можна просто використати розраховані таблиці
вузлів та вагових коефіцієнтів для квадратур Гаусса (див.
Табл.~\ref{tablG}).

\newcolumntype{d}{D{.}{.}{1.4}}

\begin{table}
\caption {\bf Вузли та вагові коефіцієнти для квадратур Гаусса}
\label{tablG} \center{
\begin{tabular}{|c|c|c|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  кількість вузлів & \multicolumn{1}{c|}{вузли для інтервалу $[-1,1]$} & \multicolumn{1}{c|}{вагові коефіцієнти} \\
  $n$ & \multicolumn{1}{c|}{$\tilde{x}_i$} & \multicolumn{1}{c|}{$C_i$} \\
  \hline \hline
  2 & $\pm\,0.577350$ & 1.0  \\ \hline
  3 & \begin{tabular}{c}
     $\pm\,0.774597$\\0.0
      \end{tabular}
    &\begin{tabular}{c}
     0.555556\\0.888889
      \end{tabular}
      \\ \hline
  4 & \begin{tabular}{c}
     $\pm\,0.861136$\\$\pm\,0.339981$
      \end{tabular}
   & \begin{tabular}{c}
     0.347855\\0.652145
      \end{tabular}
     \\ \hline
  5 & \begin{tabular}{c}
     $\pm\,0.906180$\\$\pm\,0.538469$\\0.0
      \end{tabular}
    & \begin{tabular}{c}
     0.236927\\0.478629\\0.568889
      \end{tabular}
     \\ \hline
  6 & \begin{tabular}{c}
     $\pm\,0.932470$\\$\pm\,0.661209$\\$\pm\,0.238620$
      \end{tabular}
    & \begin{tabular}{c}
     0.171325\\0.360762\\0.467914
      \end{tabular}
  \\   \hline
\end{tabular}
}
\end{table}

  \item Врахувати, що інтервал інтегрування може відрізнятися від
  $[-1,1]$ і тому остаточна формула матиме вигляд
  \begin{equation}\label{kvg4}
    \int_a^bf(x)\,dx=\frac{(b-a)}2\,\sum_{i=0}^n\,C_i\,f\left(\frac{a+b}2+
    \frac{b-a}2\cdot\tilde{x}_i\right)\,.
  \end{equation}

\end{list}


\vspace{.3cm}
\begin{Zavd}\label{Z81}
Написати процедуру пошуку інтегралу за допомогою квадратур
Ньютона-Котеса, використовуючи
 \begin{enumerate}[a)]
 \renewcommand{\alph}[1]{\asbuk{#1}}
  \setlength{\itemsep}{0.0cm}
 \item метод прямокутників з різним положенням центру;
 \item метод трапецій;
 \item метод парабол (Сімпсона).
 \end{enumerate}
\end{Zavd}

\begin{Zavd}\label{Z82}
Написати процедуру пошуку інтегралів за допомогою квадратур Гаусса з 3
та з 5 вузлами.
\end{Zavd}

\vspace{.5cm} \textbf{\emph{Орієнтовні алгоритми}}

\vspace{.5cm} \emph{Завдання \ref{Z81}} \nopagebreak
\begin {enumerate} [i.]
\item Зчитати дані з файлу у двовимірний масив та визначити кількість точок,
по яким буде проводитись інтегрування.

\item Для методу парабол перевірити
  \begin{enumerate}[a)]
   \setlength{\itemsep}{0.0cm}
  \renewcommand{\alph}[1]{\asbuk{#1}}
     \item що точок більше двох;
     \item рівномірність мережі.
    \end{enumerate}
\item Користуючись
\begin{itemize}
\setlength{\itemsep}{0.0cm}
\renewcommand{\labelitemi}{--}
  \item виразом \eqref{chi7} для методу прямокутників з центруванням на лівій
  границі
  \item виразом \eqref{tr2} для методу трапецій
  \item виразом \eqref{sim1} для методу Сімпсона
\end{itemize}
обчислити значення інтегралу.
\item Вивести на екран (або у файл) отримані результати.
\end{enumerate}

\vspace{.5cm} \emph{Завдання \ref{Z82}}
\begin {enumerate} [i.]
\item  Створити функцію, яка обчислює значення підінтегрального
виразу.

\item Використовуючи $\tilde{x_i}$ та $C_i$ з таблиці~\ref{tablG}
(третій та п'ятий рядки) за допомогою виразу \eqref{kvg4} обчислити
значення інтегралу.

\item Вивести на екран (або у файл) отримані результати.
\end{enumerate}

\clearpage

\addcontentsline{toc}{subsection}{Список літератури}
\renewcommand{\refname}{Список літератури}
\begin{thebibliography}{99}
\end{thebibliography}


\begin{enumerate}[1.]
\item Дж. Форсайт, М. Малькольм, К. Моулер \emph{Машинные методы математических вычислений}
  (М., Мир, 1980, 280 c.)
  \item Н.Н. Калиткин \emph{Численные методы }(М., Наука, 1978, 512 c.)
  \item Л.И. Турчак, П.В. Плотников \emph{Основы численных методов}
  (М., Физматлит, 2003, 304 с.)
  \item В.А. Буслов, С.Л. Яковлев \emph{Введение в численный анализ}
  (Санкт-Петербург, Из-во Санкт-Петербурского Государственного
  университета, 1999, 99 с.)
  \item И.Б. Петров, А.И. Лобанов \emph{Лекции по вычислительной
  математике} (М., Бином. Лаборатория знаний, 2006, 529 с.)
  \item Н.С. Бахвалов, Н.П. Жидков, Г.М. Кобельников \emph{Численные
  методы} (М., Физматлит, 2002, 630~с.)
  \item Д. Каханер, К. Моулер, С. Нэш \emph{Численные методы и програмное
  обеспечение} (М., Мир, 1998, 575 с.)
  \item А.А.Самарский \emph{Введение в численные методы} (М., Лань, 2009,
  288 с.; М., Наука, 1997, 234 с.; М., Наука, 1987, 269 с.)
  \item С.М. Єжов \emph{Методи обчислень} (К., Київ.ун-тет, 2001, 174
  с.)
\end{enumerate}




\end{document}
